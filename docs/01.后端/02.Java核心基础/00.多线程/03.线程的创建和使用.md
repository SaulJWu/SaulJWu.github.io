---
title: 线程的创建和使用
date: 2020-12-17 12:47:40
permalink: /pages/81ea6e/
categories:
  - 后端
  - Java核心基础
  - 多线程
tags:
  - Thread类
---
> 这是多线程吗？

~~~java
public class Sample{
    public void method1(String str){
        System.out.println(str);
    }
    
    public void method2(String str){
        method1(str);
    }
    
    public static void main(String[] args){
        Sample s = new Sample();
        s.method2("hello!");
    }
}
~~~

不是多线程，这个案例一条线程就可以完成了。



## Thread类

- `Java`语言的`JVM`允许程序运行多个线程，它通过`java.lang.Thread`类来体现。
- `Thread`类的特性
  - 每个线程都是通过某个特定`Thread`对象的`run()`方法来完成操作的，经常**把`run()`方法的主体称为线程体**。
  - 通过该`Thread`对象的`start()`方法来启动这个线程，而非直接调用`run()`。



> 构造器

- `Thread()`：创建新的Thread对象。
- `Thread(String threadname)`：创建线程并指定线程实例名。
- `Thread(Runnabletarget)`：指定创建线程的目标对象，它实现了`Runnable`接口中的`run()`方法。
- `Thread(Runnable target, String name)`：创建新的`Thread`对象。



## 实现方式

> API中创建线程的两种方式

**JDK1.5之前创建新执行线程有两种方法：**

- 1、继承`Thread`类的方式
- 2、实现`Runnable`接口的方式





> **方式一：继承`Thread`类**

1. 定义子类继承`Thread`类。
2. 子类中重写`Thread`类中的`run()`方法.
3. 创建`Thread`子类对象，即创建了线程对象。
4. 调用线程对象`start`方法：启动线程，调用`run`方法。



**Java Platform SE 8**：

> There are two ways to create a new thread of execution. One is to declare a  class to be a subclass of `Thread`. This subclass should override the  `run` method of class `Thread`. An instance of the  subclass can then be allocated and started. For example, a thread that computes  primes larger than a stated value could be written as follows: 

~~~java
class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }

         public void run() {
             // compute primes larger than minPrime
              . . .
         }
}
~~~

> start方法启动当前线程，并调用当前线程的`run()`

![image-20201217173122670](C:\Users\SaulJ\AppData\Roaming\Typora\typora-user-images\image-20201217173122670.png)



> **方式二：实现`Runnable`接口**

1. 定义子类，实现`Runnable`接口。
2. 子类中重写`Runnable`接口中的`run`方法。
3. 通过`Thread`类含参构造器创建线程对象。
4. 将`Runnable`接口的子类对象作为实际参数传递给`Thread`类的构造器中。
5. 调用`Thread`类的`start`方法：开启线程，调用`Runnable`子类接口的`run`方法。





## 练习

> **比如：遍历100以内的奇数和偶数，分开线程实现：**

~~~java
public class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+"   ---  i = " + i);
            }
        }
    }
}
~~~

~~~java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            System.out.println(Thread.currentThread().getName()+"   ***  i = " + i);
        }
    }
}
~~~

输出结果：

<img src="https://raw.githubusercontent.com/SaulJWu/images/main/20201217175037.png" alt="image-20201217173900008" style="zoom:50%;" />

`Thread.currentThread().getName()`获取当前线程的名字。

可以看到2个线程都是独立运行的。



> 问题一：如果自己调用run()方法，可以吗？

改改上面的测试案例，试试：

~~~java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    //        t1.start();
    t1.run();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            System.out.println(Thread.currentThread().getName()+"   ***  i = " + i);
        }
    }
}
~~~

![image-20201217174405724](https://raw.githubusercontent.com/SaulJWu/images/main/20201217175031.png)

可以看到，只有一个线程，而且是顺序执行，只是普通方法，没有启动多线程模式。

而且`idea`已经告诉你了：

![image-20201217174603952](https://raw.githubusercontent.com/SaulJWu/images/main/20201217175029.png)



> 问题二：试试多次调用同一个线程对象

~~~java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    t1.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            System.out.println(Thread.currentThread().getName()+"   ***  i = " + i);
        }
    }
}
~~~

结果：

![image-20201217174752036](C:\Users\SaulJ\AppData\Roaming\Typora\typora-user-images\image-20201217174752036.png)

第二次启动线程时，报`java.lang.IllegalThreadStateException`错，不能重复调用。

我们来点击一下`start`方法，看看源码：

![image-20201217174934212](https://raw.githubusercontent.com/SaulJWu/images/main/20201217174934.png)

已经`start`的线程，它的`threadStatus`不为0，肯定会抛出`java.lang.IllegalThreadStateException`异常。

那么最后我们只能重新再创建一个线程的对象，然后调用`start`方法：

~~~java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    MyThread t2 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    t2.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            System.out.println(Thread.currentThread().getName()+"   ***  i = " + i);
        }
    }
}
~~~

运行结果：

![image-20201217175221321](https://raw.githubusercontent.com/SaulJWu/images/main/20201217175221.png)

**要想调用多线程，只能创建多个线程对象。**



> 优化代码，使用Thread类的匿名子类的方式

既然都是只用一次，那么可以作为匿名子类的方式来运行。

```java
@Test
void TestInnerThread(){
    new MyThread(){
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (i % 2 != 0) {
                    System.out.println(Thread.currentThread().getName()+"   ***  i = " + i);
                }
            }
        }
    }.start();
    new MyThread(){
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (i % 2 == 0) {
                    System.out.println(Thread.currentThread().getName()+"   ---  i = " + i);
                }
            }
        }
    }.start();
}
```

这样虽然可以启动2个线程，但是没有达到并行效果：

![image-20201217184742972](https://raw.githubusercontent.com/SaulJWu/images/main/20201217184743.png)

一个线程执行完毕后，才执行第二个线程，这样达不到我们预期的效果，



> 事实上，还可以定义一个内部类，让重复代码减少，也能实现并行效果：

```java
class Mythread extends Thread {

    private int x;


    public Mythread(int x) {
        this.x = x;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (this.x % 2 != 0 && i % 2 != 0) {
                System.out.println(Thread.currentThread().getName() + "   ---  i = " + i);
            } else {
                System.out.println(Thread.currentThread().getName() + "   ---  i = " + i);
            }
        }
    }
}

@Test
void TestOuterThread2() {
    new Mythread(1).start();
    new Mythread(2).start();
}
```

![image-20201217184851323](https://raw.githubusercontent.com/SaulJWu/images/main/20201217184851.png)

这样就满足我们的并行效果了



> 总结：

- 如果自己手动调用`run()`方法，那么就只是普通方法，没有启动多线程模式。
- **`run()`方法由`JVM`调用，什么时候调用，执行的过程控制都有操作系统的`CPU`调度决定。**
- **想要启动多线程，必须调用`start`方法。**
- 一个线程对象只能调用一次`start()`方法启动，如果重复调用了，则将抛出以上的异常“`IllegalThreadStateException`”。



## Thread类的常用方法

- `void start()`:  启动线程，并执行对象的run()方法
- `run()`:  线程在被调度时执行的操作
- `String getName()`:  返回线程的名称
- `void setName(String name)`:设置该线程名称
- `static Thread currentThread()`: 返回当前线程。在`Thread`子类中就是`this`，通常用于主线程和`Runnable`实现类
- `yield()`：线程让步，释放当前cpu的执行权
- `join()：`当某个程序执行流中调用其他线程的join() 方法时，当前线程将被阻塞，直到join() 方法加入的join 线程执行完为止
- `sleep(long millitime)`：线程休眠/睡眠，实际上就是阻塞。
- `stop()`：强制线程生命期结束，不推荐使用（已过时）
- `isAlive()`：返回`boolean`，判断线程是否还活着



### 线程名相关

> 关于Thread类的命名

我们来看看源码：

```java
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

```java
/* For autonumbering anonymous threads. */
private static int threadInitNumber;
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
```

所以这里我们就知道它的默认命名规则了，`threadInitNumber`是全局常量，默认值是0

而且我还发现，main方法的`threadInitNumber`是从0开始，单元测试的`threadInitNumber`是从1开始。

事实上，它还有一个带命名的一个构造器：

```java
public Thread(String name) {
    init(null, null, name, 0);
}
```



> 主线程其实也可以改变名字

```java
Thread.currentThread().setName("test主线程");
```

完整代码：

```java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    MyThread t2 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    t2.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            Thread.currentThread().setName("test主线程");
            System.out.println(Thread.currentThread().getName() + "   ***  i = " + i);
        }
    }
}
```

`static Thread currentThread()`: 返回当前线程，返回了当前线程的对象，那么我们就可以操作它了。



### yield

> `yield()`：线程让步，释放当前cpu的执行权
>
> 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
>
> 若队列中没有同优先级的线程，忽略此方法

```java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            Thread.currentThread().setName("test主线程");
            System.out.println(Thread.currentThread().getName() + "   ***  i = " + i);
        }
    }
}
```

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(Thread.currentThread().getName()+"   ---  i = " + i);
            }
            if (i % 20 == 0) {
                this.yield();
            }
        }
    }
}
```

一旦线程执行此方法，释放当前CPU的执行，虽然多次测试效果不是很理想，但是因为下次分配，此线程又抢到了运行。



### join

> `join()：`当某个程序执行流中调用其他线程的join() 方法时，当前线程将被阻塞，直到join() 方法加入的join 线程执行完为止
>
> 低优先级的线程也可以获得执行

```java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            Thread.currentThread().setName("test主线程");
            System.out.println(Thread.currentThread().getName() + "   ***  i = " + i);
        }
        if (i == 20) {
            try {
                t1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(this.getName()+"   ---  i = " + i);
            }
        }
    }
}
```

现在，主线程执行到20，就开始执行子线程，等到子线程执行完毕后，才让主线程执行。



### sleep

> `sleep(long millitime)`：线程休眠/睡眠，实际上就是阻塞。

令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。

抛出`InterruptedException`异常。

```java
@Test
void run3() throws InterruptedException {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            Thread.sleep(1000);
            Thread.currentThread().setName("test主线程");
            System.out.println(Thread.currentThread().getName() + "   ***  i = " + i);
        }
    }
}
```

```java
@Override
public void run() {
    for (int i = 0; i < 100; i++) {
        if (i % 2 == 0) {
            System.out.println(this.getName()+"   ---  i = " + i);
        }
    }
}
```

这次可以看到子线程已经立刻完成了，而主线程还在等一秒执行一次。



> 套路？网络图

![image-20201217190940145](https://raw.githubusercontent.com/SaulJWu/images/main/20201217190940.png)



### isAlive

> `isAlive()`：返回`boolean`，判断线程是否还活着

```java
@Test
void run() {
    //创建`Thread`子类对象，即创建了线程对象。
    MyThread t1 = new MyThread();
    //调用线程对象`start`方法：启动线程，调用`run`方法。
    t1.start();
    //主线程
    for (int i = 0; i < 100; i++) {
        if (i % 2 != 0) {
            Thread.currentThread().setName("test主线程");
            System.out.println(Thread.currentThread().getName() + "   ***  i = " + i);
        }
        if (i == 20) {
            try {
                t1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    System.out.println("t1.isAlive() = " + t1.isAlive());
}
```



## 线程的调度

> 调度策略

- 时间片：默认是此策略，执行完一个线程然后再执行另一个线程。
- 抢占式：高优先级的线程抢占CPU。



> Java的调度方法

- 同优先级线程组成先进先出队列（先到先服务），使用时间片策略
- 对高优先级，使用优先调度的抢占式策略



## 线程优先级

- 线程的优先级等级
  - MAX_PRIORITY：10
  - MIN _PRIORITY：1
  - NORM_PRIORITY：5，默认优先级
- 涉及的方法
  - getPriority() ：返回线程优先值
  - setPriority(intnewPriority) ：改变线程的优先级
- 说明
  - 线程创建时继承父线程的优先级
  - **低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用**



> 先前我们有一个案例，使用Thread类的匿名子类的方式，但是它们不是并行效果，现在可以设置线程优先级，让线程并行

```java
class Mythread extends Thread {

    private int x;


    public Mythread(int x) {
        this.x = x;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (this.x % 2 != 0 && i % 2 != 0) {
                System.out.println(getName() + ":" + getPriority() + ":" + i);
            } else {
                System.out.println(getName() + ":" + getPriority() + ":" + i);
            }
        }
    }
}

@Test
void TestOuterThread2() {
    Mythread t1 = new Mythread(1);
    t1.setPriority(1);
    t1.start();
    Mythread t2 = new Mythread(2);
    t2.setPriority(10);
    t2.start();
}
```

输出结果：

![image-20201217194714331](https://raw.githubusercontent.com/SaulJWu/images/main/20201217194714.png)

从多次执行单元测试结果，可以看出，**低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用**