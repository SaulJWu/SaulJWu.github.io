---
title: 抽象类与抽象方法
date: 2020-12-16 10:48:26
permalink: /pages/0bfa4f/
categories: 
  - 后端
  - Java入门基础
  - 面向对象
tags: 
  - abstract
  - 抽象类
  - 抽象方法
---


## 抽象类

随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。

<img src="https://raw.githubusercontent.com/SaulJWu/images/main/20201216104929.png" alt="image-20201216104928967" style="zoom:50%;" />

> 用`abstract`关键字来修饰一个类，这个类叫做**抽象类**。

**抽象类不能实例化。**

**抽象类中一定有构造器，便于子类实例化时调用。（涉及：子类对象实例化的全过程）**

**开发中，都会提供抽象类的子类，让子类对象可以实例化，完成相关的操作。**



## 抽象方法

> 用`abstract`来修饰一个方法，该方法叫做**抽象方法**。

抽象方法：只有方法的声明，没有方法的实现。以分号结束：

```java
public abstract void talk();
```

**含有抽象方法的类必须被声明为抽象类。**反之，抽象类中可以没有抽象方法。

**抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。**

**若没有重写全部的抽象方法，仍为抽象类。**

不能用`abstract`修饰变量、代码块、构造器；

不能用`abstract`修饰私有方法、静态方法、final的方法、final的类。



## 应用场景

> 抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。

抽象类和抽象方法的应用场景，其实在于规范。

比如：

几何图形有很多种，那么每种图形的面积、体积计算方式都不一致，可以定义一个几何图形抽象类，然后具体图形全部继承抽象类，抽象类声明一个方法，例如求面积或者体积，那么它的子类必须重写这个方法。



比如：

![image-20201216130146012](https://raw.githubusercontent.com/SaulJWu/images/main/20201216130146.png)

在航运公司系统中，Vehicle类需要定义两个方法分别计算运输工具的燃料效率和行驶距离。

卡车(Truck)和驳船(RiverBarge)的燃料效率和行驶距离的计算方法完全不同。Vehicle类不能提供计算方法，但子类可以。



> 多态的应用：模板方法设计模式(`TemplateMethod`)

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

解决问题：

- 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
- 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。



模板方法设计模式是编程中经常用得到的模式。

各个框架、类库中都有他的影子，比如常见的有：

- 数据库访问的封装
- Junit单元测试
- JavaWeb的Servlet中关于doGet/doPost方法调用
- Hibernate中模板程序
- Spring中JDBCTemlate、HibernateTemplate等



## 抽象类的匿名子对象

有时候，我们对一个抽象类也不能确定具体实现类是什么，可以这样来写:

比如Person类是抽象类，有2个抽象方法：eat和walk

~~~java
Person person = new Person(){
    @Override
    public void eat() {
        System.out.println("吃饭");
    }

    @Override
    public void walk() {
        System.out.println("走路");
    }
};
~~~

本来抽象类不能被实例化，但是现在写的是抽象类的匿名子类对象，直接重写，有时候方法不复杂，或者只使用一次，可以使用这种快捷方便的写法。

当也可以写匿名子类的匿名对象，连返回值都不用了。

