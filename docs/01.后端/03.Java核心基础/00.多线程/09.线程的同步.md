---
title: 线程的同步
date: 2020-12-20 01:48:07
permalink: /pages/c793ed/
categories:
  - 后端
  - Java核心基础
  - 多线程
tags:
  - synchronized关键字
  - 同步锁
  - 死锁
  - lock关键字
---
## 问题的提出

- 多个线程执行的不确定性引起执行结果的不稳定
- 多个线程对账本的共享，会造成操作的不完整性，会破坏数据。

比如：当你和媳妇去取钱时，2个线程都是取2000元，但是账户里面只有3000，这时如果多线程安全问题不解决，就会出现2个人都能取钱成功。

程序执行是需要时间的，虽然这个时间极短，当一个线程判断为true时，还未执行到扣钱的时候，另一个线程同事也达到了判断条件，并且判断true时，那么2个线程都能取钱，这就是线程安全问题。

![image-20201220014906253](https://raw.githubusercontent.com/SaulJWu/images/main/20201220014906.png)

> 包括之前的3个窗口卖票的场景，也会出现线程安全问题。

```java
class Window2 implements Runnable {

    private int ticket = 100;

    public void run() {
        while (true) {
            if (ticket > 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                ticket--;
            } else {
//                System.out.println(Thread.currentThread().getName() + "抢不到票，卖光了！");
                break;
            }
        }
    }


}

public class WindowTest2 {
    public static void main(String[] args) {
        Window2 w1 = new Window2();java
        Thread t1 = new Thread(w1);
        Thread t2 = new Thread(w1);
        Thread t3 = new Thread(w1);
        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```

```
窗口2:卖票，票号为：100
窗口1:卖票，票号为：100
窗口3:卖票，票号为：100
窗口3:卖票，票号为：97
窗口2:卖票，票号为：97
窗口1:卖票，票号为：97
窗口2:卖票，票号为：94
窗口1:卖票，票号为：94
窗口3:卖票，票号为：94
窗口2:卖票，票号为：91
窗口3:卖票，票号为：91
窗口1:卖票，票号为：91
窗口3:卖票，票号为：88
窗口1:卖票，票号为：88
窗口2:卖票，票号为：88
窗口3:卖票，票号为：85
窗口1:卖票，票号为：85
窗口2:卖票，票号为：85
窗口3:卖票，票号为：82
窗口2:卖票，票号为：82
窗口1:卖票，票号为：82
窗口2:卖票，票号为：79
窗口3:卖票，票号为：79
窗口1:卖票，票号为：79
窗口1:卖票，票号为：76
窗口2:卖票，票号为：76
窗口3:卖票，票号为：76
窗口1:卖票，票号为：73
窗口2:卖票，票号为：73
窗口3:卖票，票号为：73
窗口2:卖票，票号为：70
窗口3:卖票，票号为：70
窗口1:卖票，票号为：70
窗口1:卖票，票号为：67
窗口3:卖票，票号为：67
窗口2:卖票，票号为：67
窗口3:卖票，票号为：64
窗口2:卖票，票号为：64
窗口1:卖票，票号为：64
窗口3:卖票，票号为：61
窗口1:卖票，票号为：61
窗口2:卖票，票号为：61
窗口2:卖票，票号为：58
窗口1:卖票，票号为：58
窗口3:卖票，票号为：58
窗口2:卖票，票号为：55
窗口1:卖票，票号为：55
窗口3:卖票，票号为：55
窗口2:卖票，票号为：52
窗口3:卖票，票号为：52
窗口1:卖票，票号为：52
窗口2:卖票，票号为：49
窗口1:卖票，票号为：49
窗口3:卖票，票号为：49
窗口3:卖票，票号为：46
窗口2:卖票，票号为：46
窗口1:卖票，票号为：46
窗口1:卖票，票号为：43
窗口2:卖票，票号为：43
窗口3:卖票，票号为：43
窗口3:卖票，票号为：40
窗口2:卖票，票号为：40
窗口1:卖票，票号为：40
窗口1:卖票，票号为：37
窗口2:卖票，票号为：37
窗口3:卖票，票号为：37
窗口2:卖票，票号为：34
窗口3:卖票，票号为：34
窗口1:卖票，票号为：34
窗口3:卖票，票号为：31
窗口2:卖票，票号为：31
窗口1:卖票，票号为：31
窗口2:卖票，票号为：28
窗口1:卖票，票号为：28
窗口3:卖票，票号为：28
窗口1:卖票，票号为：25
窗口2:卖票，票号为：25
窗口3:卖票，票号为：25
窗口3:卖票，票号为：22
窗口2:卖票，票号为：22
窗口1:卖票，票号为：22
窗口1:卖票，票号为：19
窗口3:卖票，票号为：19
窗口2:卖票，票号为：19
窗口2:卖票，票号为：16
窗口3:卖票，票号为：16
窗口1:卖票，票号为：16
窗口1:卖票，票号为：13
窗口2:卖票，票号为：13
窗口3:卖票，票号为：13
窗口1:卖票，票号为：10
窗口3:卖票，票号为：10
窗口2:卖票，票号为：10
窗口3:卖票，票号为：7
窗口2:卖票，票号为：7
窗口1:卖票，票号为：7
窗口2:卖票，票号为：4
窗口3:卖票，票号为：4
窗口1:卖票，票号为：4
窗口3:卖票，票号为：1
窗口1:卖票，票号为：1
窗口2:卖票，票号为：1
```

这里不但会出现重复票的事情，还有可能是负数。

`sleep`只是为了模拟线程的阻塞状态，目的是提高安全隐患爆发的概率，提升出现0或者1出现的概率。

不能因为概率小就不会出现，不去解决，这是错误的，在程序中，就算是0.01%也要去解决。

否则在现实业务场景中，产生问题造成的经济损失无法估量。可能你不理解这句话的意思，打个夸张的比喻，当坐飞机，每一万次航班出现一次故障，那么它的后果就非常恐怖了。



## 问题的原因

那么一定会出现线程安全问题吗？

也不一定，但是只要操作同一个共享数据时，就可能会发生，比如火车站抢票、明星演唱会抢票、电商网站秒杀活动等等。这些都会存在安全隐患。

就拿上面卖票的案例，票数应该是递减才对，不会出现重票或错票。是的在理想状态下是这样，但是如果是极端状态，别的线程也一起进去操作数据时，就会产生线程安全问题。

> 理想的状态

![image-20201220021135568](https://raw.githubusercontent.com/SaulJWu/images/main/20201220021135.png)



> 极端状态

![image-20201220021158731](https://raw.githubusercontent.com/SaulJWu/images/main/20201220021158.png)



**当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。**



## 解决办法

对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。

那么怎么实现呢？就是**加锁**。

## Synchronized关键字

Java对于多线程的安全问题提供了专业的解决方式：**同步机制**。

有两种方式来实现同步机制：

- 同步代码块
- 同步方法



> 同步代码块：

```java
synchronized (同步监视器){
	// 需要被同步的代码；
}
```

- 需要被同步的代码：是指操作**共享数据**的代码，即为需要被同步的代码。
  - 共享数据：多个线程共同操作的变量。比如：本案例中的`ticket`变量。
- 同步监视器：俗称：**锁**。**任何一个类的对象，都可以充当锁。**
  - **要求：多个线程必须要公用同一把锁。**



> 同步方法

`synchronized`还可以放在方法声明中，表示整个方法为同步方法

例如：

```java
public synchronized void show (String name){
	....
}
```

在同步方法中，它的同步监视器其实是`this`

## 分析同步原理

![image-20201220023815785](https://raw.githubusercontent.com/SaulJWu/images/main/20201220023815.png)

t1、t2、t3、看谁先抢到同步锁，抢到了同步锁的线程，进入代码块内，操作数据，其他线程等待，等操作完毕，线程将同步锁释放，3个线程又重新开始抢同步锁，一直循环……

在Java中，通过同步机制，来解决了线程的安全问题。但是操作同步代码时，只能有一个线程参与，其他线程等待。相当于一个单线程的过程，效率变低了。



> 使用同步代码块解决案例线程安全问题

```java
class Window implements Runnable {

    //共享数据
    private int ticket = 100;

    //监视器/锁
   private static final Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                if (ticket > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
                    ticket--;
                } else {
//                System.out.println(Thread.currentThread().getName() + "抢不到票，卖光了！");
                    break;
                }
            }
        }
    }


}

public class WindowTest {
    public static void main(String[] args) {
        Window w1 = new Window();
        Thread t1 = new Thread(w1);
        Thread t2 = new Thread(w1);
        Thread t3 = new Thread(w1);
        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```

输出结果是递减了，虽然很多次都是窗口1，但是只是概率问题，全部被`t1`抢到了同步锁，有时还是能有其他线程能同步抢到了。



> 使用同步方法解决实现Runnable案例线程安全问题

其实这个案例不太适合使用同步方法，因为`while`也是在操作共享数据时的必要条件。如果使用同步方法，`会导致一个窗口一直售票，其他窗口都拿不到锁。所以还需要定义另一个方法。

```java
class Window2 implements Runnable {

    //共享数据
    private int ticket = 100;

    @Override
    public void run() {
        while (ticket > 0) {
            this.show();
        }
    }

    private synchronized void show() {
        if (ticket > 0) {
//            try {
//                Thread.sleep(100);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
            System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
            ticket--;
        }
    }


}

public class WindowTest2 {
    public static void main(String[] args) {
        Window2 w1 = new Window2();
        Thread t1 = new Thread(w1);
        Thread t2 = new Thread(w1);
        Thread t3 = new Thread(w1);
        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```

> 使用同步方法处理继承Thread类的方式中的线程安全问题

```java
class Window4 extends Thread {
    private static int ticket = 100;

    @Override
    public void run() {
        while (ticket > 0) {
            show();
        }
    }

    private static synchronized void show() {//同步监视器为Window4.class
//        private  synchronized void show() 同步监视器为t1,t2,t3，此种解决方式是错误的
        if (ticket > 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket);
            ticket--;
        }
    }
}

public class WindowTest4 {
    public static void main(String[] args) {
        Window4 t1 = new Window4();
        Window4 t2 = new Window4();
        Window4 t3 = new Window4();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```



## 关于同步方法的总结

在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。

> synchronized的锁是什么？

- 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。
- 同步方法的锁：
  - 静态方法（`类名.class`），当前类本身
  - 非静态方法（`this`），当前对象
- 同步代码块：自己指定，很多时候也是指定为`this`或`类名.class`

> 注意

- 必须确保使用同一个资源的**多个线程共用一把锁**，这个非常重要，否则就无法保证共享资源的安全

- 一个线程类中的所有静态方法共用同一把锁（`类名.class`），所有非静态方法共用同一把锁（`this`），同步代码块（**指定需谨慎**）

  - 需要谨慎的原因是，如果是继承方式实现多线程，是多个对象，`this`是指当前对象，肯定不是同一把锁，所以需要用`类名.class`

  - `类名.class`，类也是对象。而且也是唯一的对象，因为类只会加载一次。那么就可以成为共用的一把锁。

  - ```java
    Class clazz = Window.class;
    ```



## 同步范围

> 1、如何找问题，即代码是否存在线程安全？（非常重要）

- 明确哪些代码是多线程运行的代码
- 明确多个线程是否有共享数据
- 明确多线程运行代码中是否有多条语句操作共享数据

> 2、如何解决呢？（非常重要）

对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。

**即所有操作共享数据的这些语句都要放在同步范围中**。

> 3、切记

范围太小：没锁住所有有安全问题的代码

范围太大：没发挥多线程的功能。



## 释放锁的操作

- 当前线程的同步方法、同步代码块执行结束。
- 当前线程在同步代码块、同步方法中遇到`break`、`return`终止了该代码块、该方法的继续执行。
- 当前线程在同步代码块、同步方法中出现了未处理的`Error`或`Exception`，导致异常结束。
- 当前线程在同步代码块、同步方法中执行了线程对象的`wait()`方法，当前线程暂停，并释放锁。



## 不会释放锁的操作

- 线程执行同步代码块或同步方法时，程序调用`Thread.sleep()`、`Thread.yield()`方法暂停当前线程的执行。
- 线程执行同步代码块时，其他线程调用了该线程的`suspend()`方法将该线程挂起，该线程不会释放锁（同步监视器）。
  - 应尽量避免使用`suspend()`和`resume()`来控制线程8.4 线程的同步



## 懒汉式线程安全问题

> 使用同步机制，将单例模式中的懒汉式改写为线程安全的。

回顾懒汉式实现步骤：

1、私有化构造器

2、声明当前类的对象

3、提供公共的静态方法返回类的对象

> 线程安全有问题的写法：

```java
public class Bank{
    //1,私有化构造器
    private Bank() {
        
    }
	
    //2,声明当前类的对象
    private static Bank instance = null;
	
    //3,提供公共的静态方法返回类的对象
    public static Bank getInstance() {
        if (instance == null) {
            instance = new Bank();
        }
        return instance;
    }
}
```

> 同步方法解决方案

```java
public class Bank {
    private Bank() {

    }

    private static Bank instance = null;

    public static synchronized Bank getInstance() {
        if (instance == null) {
            instance = new Bank();
        }
        return instance;
    }
}
```

> 同步代码块解决方案

```java
public class Bank {
    private Bank() {

    }

    private static Bank instance = null;

    public static Bank getInstance() {
        synchronized (Bank.class) {
            if (instance == null) {
                instance = new Bank();
            }
        }
        return instance;
    }
}
```

这种方式效率稍差，为什么？

当对象未创建时，可以用`synchronized`来确保只有一个对象被创建，不会产生线程安全问题。

但是对象如果已经被创建后，其实可以直接返回对象了，`return`不是操作共享数据的，当对象已经创建时，所有线程还是要排队一个个地拿到同步锁，才能获取对象，所以效率稍差。