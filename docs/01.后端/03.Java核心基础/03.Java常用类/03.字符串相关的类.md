---
title: 字符串相关的类
date: 2020-12-22 23:39:00
permalink: /pages/16db16/
categories:
  - 后端
  - Java核心基础
  - Java常用类
tags:
  - String
---
## String

### Sttring的特性

- **`String`类：代表字符串**。`Java` 程序中的所有字符串字面值（如"`abc`" ）都作为此类的实例实现。
- `String`是一个`final`类，代表**不可变的字符序列*，不可被继承。简称不可变性。
  - 体现：当字符串重新赋值(包括连接操作或`replace()`方法)时，需要重写指定内存区域赋值，不能使用原有的`value`进行赋值。
- 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。
- `String`实现了`Serializable`接口，表示字符串是支持序列化的。
- `String`实现了`Comparable`接口，表示`String`可以比较大小。
- `String`对象的字符内容是存储在一个字符数组`value[]`中的。

![image-20201223000330420](https://raw.githubusercontent.com/SaulJWu/images/main/20201223000330.png)



### 内存解析

![image-20201223001721451](https://raw.githubusercontent.com/SaulJWu/images/main/20201223001721.png)

`String`通过字面量的方式(区别于`new`关键字)给一个字符串赋值，此时的字符串值声明在字符串的常量池中。

`String`首次会去字符串常量池中找是否有相同值的内容，如果有直接将引用指向该地址，

如果没有，就在字符串常量池在开辟新的空间，再将引用指向这个地址。

所以**字符串常量池**中是不会有相同内容。

~~~java
@Test
public void test01(){
    String str = "abc";
    System.out.println(str.getBytes());
    str = "bcd";
    System.out.println(str.getBytes());
    str += "def";
    System.out.println(str.getBytes());
}
~~~

```
[B@37d31475
[B@27808f31
[B@436e852b
```

```java
@Test
public void test02() {
    String str = "abc";
    System.out.println(str.getBytes());
    //替换a为mjava
    String s = str.replace('a', 'm');
    System.out.println(s.getBytes());
}
```

~~~
[B@37d31475
[B@27808f31
~~~



### String对象的创建

```java
//字面量的方式，最常用
String str = "hello";

//本质上this.value = new char[0];
String  s1 = newString(); 

//this.value = original.value;
String  s2 = newString(String original); 

//this.value = Arrays.copyOf(value, value.length);
String  s3 = newString(char[] a); 

//从char数组中截取成字符串，startIndex开始截取的位置,count截取多少位
String  s4 = newString(char[] a,int startIndex,int count);
```



### 字面量和new字符串区别

![image-20201223003555800](https://raw.githubusercontent.com/SaulJWu/images/main/20201223003555.png)

- 通字面量定义的方式，数据是声明在方法区的字符串常量池中。
- 我们都知道凡是用`new关键字+构造器`的方式，都会在堆内存中开辟新的空间，将引用指向该地址，**如果是字符串还要在常量池中新建一个`char[]`，存储具体值，堆空间站的结构再指向常量池的地址。**

```java
@Test
public void test03() {
    String s1= "java";
    String s2= "java";
    String s3 = new String("java");
    String s4 = new String("java");
    System.out.println(s1 == s2);//true
    System.out.println(s1 == s3);//false
    System.out.println(s1 == s4);//fasle
    System.out.println(s3 == s4);//fasle
}
```



### 字符串对象如何存储

![image-20201223004226970](https://raw.githubusercontent.com/SaulJWu/images/main/20201223004227.png)

![image-20201223004253850](https://raw.githubusercontent.com/SaulJWu/images/main/20201223004253.png)



### 面试题

请问下面方式在内存中创建连几个对象？

```java
String s = new String("abc");
```

两个，一个是堆空间中new结构，另个一个是char[]对应常量池中的数据:“abc”



### 练习

~~~java
@Test
public void test04() {
    String s1 = "javaEE";
    String s2 = "hadoop";
    
    String s3 = "javaEEhadoop";
    String s4 = "javaEE" + "hadoop";
    String s5 = s1 + "hadoop";
    String s6 = "javaEE" + s2;
    String s7 = s1 + s2;
    
    System.out.println(s3 == s4);//true
    System.out.println(s3 == s5);//false
    System.out.println(s3 == s6);//false
    System.out.println(s3 == s7);//false
    System.out.println(s5 == s6);//false
    System.out.println(s5 == s7);//false
    System.out.println(s6 == s7);//false
}
~~~

![image-20201223005542261](https://raw.githubusercontent.com/SaulJWu/images/main/20201223005542.png)



结论

- 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。
- 只要其中有一个是变量，结果就在堆中。
- 如果拼接的结果调用`intern()`方法，返回值就在常量池中。



### String使用陷阱

~~~java
String s1 = "a"; 
~~~

说明：在字符串常量池中创建了一个字面量为"a"的字符串。



```java
s1 = s1 + "b"; 
```

说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+"b"（也就是"ab")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。



~~~java
String s2 = "ab";
~~~

说明：直接在字符串常量池中创建一个字面量为"ab"的字符串。



~~~java
String s3 = "a" + "b";
~~~

说明：s3指向字符串常量池中已经创建的"ab"的字符串。



~~~java
String s4 = s1.intern();
~~~

说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的"ab"字符串赋值给s4。



### 面试题

```java
public class SpringTest02 {
    String str = new String("good");

    char[] ch = {'t', 'e', 's', 't'};


    private void change(String str, char[] ch) {
        str = "test ok";
        ch[0] = 'b';
    }

    public static void main(String[] args) {
        SpringTest02 ex = new SpringTest02();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + " and ");
        System.out.println(ex.ch);
    }
}
```

输出结果

```
good and best
```

因为调用change方法时，新建2个引用，str和ch，str是值传递，ch是引用传递

当str赋值新的值时，跟原来的值没关系，str是局部变量，出了change方法就无效了。

ch[0]虽然是新建的引用，但是和原来类的属性都是指向同一个地址，当ch[0]改变时，原来的也会改变。

增加输出语句试试：。

```java
private void change(String str, char[] ch) {
    str = "test ok";
    ch[0] = 'b';
    //增加输出语句
    System.out.println("局部变量：" + str);
    System.out.println("局部变量：" + ch);
    System.out.println("局部变量：" + Arrays.toString(ch));
    System.out.println("成员变量：" + this.str);
    System.out.println("成员变量：" + this.ch);
    System.out.println("成员变量：" + Arrays.toString(this.ch));
}
```

输出结果：

```
局部变量：test ok
局部变量：[C@135fbaa4
局部变量：[b, e, s, t]
成员变量：good
成员变量：[C@135fbaa4
成员变量：[b, e, s, t]
good and best
```

很明显，

两个ch都是指向同一个地址，它们是同一个对象，

两个str是两个对象，只不过值相同而已。