---
title: 自定义泛型结构
date: 2020-12-27 03:41:27
permalink: /pages/c6f029/
categories:
  - 后端
  - Java核心基础
  - 泛型
tags:
  - 泛型
  - T
---
## 学习目标
- 自定义泛型类
- 自定义泛型接口
- 自定义泛型方法



## 泛型的声明

```java
interface List<T>;
class GenTest<K,V>；
```

其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写。



## 泛型的实例化

一定要在类名后面指定类型参数的值（类型）。

如：

~~~java
List<String> strList= new ArrayList<String>();
Iterator<Customer> iterator = customers.iterator();
~~~

- T只能是类，不能用基本数据类型填充。但可以使用包装类填充
- 把一个集合中的内容限制为一个特定的数据类型，这就是generics背后的核心思想



## 体会

- JDK1.5之前：

```java
Comparable c = new Date();
System.out.println(c.compareTo("red"));
```

- JDK1.5之后：

```java
Comparable<Date> c = new Date();
System.out.println(c.compareTo("red"));
```

**体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误。**



## 规约

> 自定义泛型结构：泛型类、泛型接口

- 1、泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<E1,E2,E3>
- 2、泛型类的构造器如下：`public GenericClass(){}`。
  - 而下面是错误的：`public GenericClass<E>(){}`
- 3、实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。
- 4、泛型不同的引用不能相互赋值。
  - 尽管在编译时`ArrayList<String>`和`ArrayList<Integer>`是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。
- 5、**泛型如果不指定，将被擦除，泛型对应的类型均按照`Object`处理，但不等价于`Object`。经验：泛型要使用一路都用。要不用，一路都不要用。**
- 6、如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。
- 7、jdk1.7，泛型的简化操作：`ArrayList<Fruit> flist = new ArrayList<>();`
- 8、泛型的指定中不能使用基本数据类型，可以使用包装类替换。
- 9、**在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型**
  - 静态方法中不能使用类的泛型。因为静态方法是在类加载的时候就加载了，但是类的泛型要在类实例化时才知道。
    - `public static void show(T t){...}`这是错误例子。
  - 泛型方法，可以声明为静态的。因为：泛型参数是在调用方法时确定的。并非在实例化类时确定。
- 10、异常类不能是泛型的
- 11、不能使用`new E[]`。但是可以：`E[] elements = (E[])new Object[capacity]`;
  - 参考：ArrayList源码中声明：`Object[] elementData`，而非泛型参数类型数组。
- 12、父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：
  - 子类不保留父类的泛型：按需实现
    - 没有类型擦除
    - 具体类型
  - 子类保留父类的泛型：泛型子类
    - 全部保留
    - 部分保留
  - 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型。

~~~java
class Father<T1, T2> {
    
}
// 子类不保留父类的泛型
// 1)没有类型擦除
class Son<A, B> extends Father{ //等价于class Son extends Father<Object,Object>{}
}

// 2)具体类型
class Son2<A, B> extends Father<Integer, String> {}

// 子类保留父类的泛型
// 1)全部保留
class Son3<T1, T2, A, B> extends Father<T1, T2> {}

// 2)部分保留
class Son4<T2, A, B> extends Father<Integer, T2> {}
~~~

![image-20201227035934684](https://raw.githubusercontent.com/SaulJWu/images/main/20201227035934.png)





## 泛型方法

**方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。**

### 格式

泛型方法的格式：

~~~java
[访问权限] <泛型> 返回类型方法名([泛型标识参数名称]) 抛出的异常
~~~

- 泛型方法声明泛型时也可以指定上限

~~~java
public class DAO {
    public <E> E get(int id, E e) {
        E result= null;
        return result;
    }
}
~~~

**dao：data(base) access object：数据访问对象。**



- 泛型方法，可以声明为静态的。因为：泛型参数是在调用方法时确定的。并非在实例化类时确定。

比如：

![image-20201227040003474](https://raw.githubusercontent.com/SaulJWu/images/main/20201227040003.png)



比如：

![image-20201227040027666](https://raw.githubusercontent.com/SaulJWu/images/main/20201227040027.png)