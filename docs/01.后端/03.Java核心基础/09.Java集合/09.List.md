## 概述

- `Collection`子接口之一：`List`接口
- 鉴于`Java`中数组用来存储数据的局限性，我们通常使用`List`替代数组
- `List`集合类中**元素有序**、**且可重复**，集合中的每个元素都有其对应的顺序索引。
- `List`容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
- `JDK API`中`List`接口的实现类常用的有：`ArrayList`、`LinkedList`和`Vector`。



## List接口方法

`List`除了从`Collection`集合继承的方法外，`List` 集合里添加了一些根据索引来操作集合元素的方法。

- **`void add(int index, Object ele)`:在`index`位置插入`ele`元素**
- `boolean addAll(int index, Collection eles)`:从`index`位置开始将`eles`中的所有元素添加进来
- **`Object get(int index)`:获取指定`index`位置的元素**
- `int indexOf(Object obj)`:返回obj在集合中首次出现的位置
- `int lastIndexOf(Object obj)`:返回obj在当前集合中末次出现的位置
- **`Object remove(int index)`:移除指定index位置的元素，并返回此元素**
- **`Object set(int index, Object ele)`:设置指定index位置的元素为ele**
- `List subList(int fromIndex, int toIndex)`:返回从fromIndex到toIndex位置的子集合



## ArrayList

- ArrayList是List 接口的典型实现类、主要实现类
- 本质上，ArrayList是对象引用的一个”变长”数组，`Object[] elementData`

![image-20201224234807501](https://raw.githubusercontent.com/SaulJWu/images/main/20201224234807.png)

> ArrayList的JDK1.8之前与之后的实现区别？

- JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组
- JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组



> `Arrays.asList(...)` 方法返回的List 集合，既不是ArrayList实例，也不是Vector 实例。`Arrays.asList(...)`  返回值是一个固定长度的List 集合

![image-20201224234939047](https://raw.githubusercontent.com/SaulJWu/images/main/20201224234939.png)



### 源码分析

#### **JDK7：**

在jdk7时，空参实例化方式：

```java
ArrayList list = new ArrayList();
```

空参实例化时，底层是创建了长度是10的`Object[] elementData`。

添加元素时，在添加之前先确认容量是否够，不够就扩容，库容调用`ensureCapacityInternal(size + 1)`方法，`size`是原来的容量，调用`grow`方法，默认情况下，容量扩容为原来的**1.5倍**，特殊情况会将容量设置为要添加元素的容量，极端情况，容量设置为整型最大值，如果容量还不够就报超出内存异常`OutOfmemoryError()`。

扩容完以后，将原来数组中的元素拷贝过去。

**结论：建议开发中使用带参的构造器：`ArrayList list = new ArrayList(int initialCapacity)`，直接设置容量空间，避免扩容，效率会更高。**



#### **JKD8：**

先看空参构造器：

```java
ArrayList list = new ArrayList();
```

空参实例化时，底层`Object[] elementData`初始化为`{}`，并没有创建长度为10的数组，

添加元素时，第一次调用时，底层才创建了长度为10的数组，并将元素添加到集合中，后续的添加和库容操作与JDK7无异。



#### **小结：**

**jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而JKD8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。**





### 面试题





## LinkedList

- 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高

- 底层使用**双向链表**存储，内部没有声明数组，而是定义了内部类，内部类为`Node`类型的`first`和`last`，用于记录首末元素。同时，定义内部类`Node`，作为`LinkedList`中保存数据的基本结构。`Node`除了保存数据，还定义了两个变量：
  - `prev`变量记录前一个元素的位置
  - `next`变量记录下一个元素的位置



### 源码分析

先看空参的构造器：

```
LinkedList list = new LinkedList();
```

空参实例化时，内部声明了Node类型的first和last属性，默认值为null。

添加元素时，将元素封装到Node中，创建了Node对象。

其中Node为：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```



### 新增方法

- `void addFirst(Object obj)`
- `void addLast(Object obj)`
- `Object getFirst()`
- `Object getLast()`
- `Object removeFirst()`
- `Object removeLast()`



## Vector

- 底层使用`Object[] elementData` 存储
- `Vector` 是一个古老的集合，JDK1.0就有了。大多数操作与`ArrayList`相同，区别之处在于`Vector`是线程安全的。`Vector`很多方法都是用了同步方法`synchronized`。
- 在各种`list`中，最好把`ArrayList`作为缺省选择。当插入、删除频繁时，使用`LinkedList`；`Vector`总是比ArrayList慢，所以尽量避免使用

![image-20201224234856011](https://raw.githubusercontent.com/SaulJWu/images/main/20201224234856.png)



### 新增方法：

- `void addElement(Object obj)`
- `void insertElementAt(Object obj,intindex)`
- `void setElementAt(Object obj,intindex)`
- `void removeElement(Object obj)`
- `void removeAllElements()`



## 面试题

> 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?

- ArrayList和LinkedList的异同

二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据

- ArrayList和Vector的区别

Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。**Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。**Vector还有一个子类Stack。

## 总结

> `ArrayList`、`LinkedList`和`Vector`三者的异同

**同：**

- 三各类都是实现了List接口， 存储数据的特点相同：存储有序的、可重复的数据。

**不同：**

- `ArrayList`：作为List接口的主要实现类，线程不安全的，效率高；底层使用`Object[]`存储
- `LinkedList`：对于频繁的插入、删除操作，使用此类比Arraylist效率高；底层使用双向链表存储
- `Vector`：作为List接口的古老实现类，线程安全的，效率低；底层使用`Object[]`存储