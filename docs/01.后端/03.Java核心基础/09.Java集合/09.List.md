---
title: List
date: 2020-12-24 23:29:56
permalink: /pages/19f378/
categories:
  - 后端
  - Java核心基础
  - Java集合
tags:
  - List
  - ArrayList
  - LinkedList
  - Vector
---

## 前言
`Java` 集合可分为`Collection` 和`Map` 两种体系:

- `Collection`接口：单列数据，定义了存取一组对象的方法的集合
  - `List`：元素有序、可重复的集合
    - `ArrayList`、`LinkedList`、`Vector`
  - `Set`：元素无序、不可重复的集合
    - `HashSet`、`LinkedHashSet`、`TreeSet`
- `Map`接口：双列数据，保存具有映射关系“`key-value对`”的集合，也称为**键值对**。
  - `HashMap`、`LinkedHashMap`、`TreeMap`、`Hashtable`、`Properties` 



**现在我们开始学习List接口。**



## 概述

- 鉴于`Java`中数组用来存储数据的局限性，我们通常使用`List`替代数组
- `List`集合类中**元素有序**、**且可重复**，集合中的每个元素都有其对应的顺序索引。
- `List`容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
- `JDK API`中`List`接口的实现类常用的有：`ArrayList`、`LinkedList`和`Vector`。



## List接口方法

`List`除了从`Collection`集合继承的方法外，`List` 集合里添加了一些根据索引来操作集合元素的方法。

- **`void add(int index, Object ele)`:在`index`位置插入`ele`元素**
- `boolean addAll(int index, Collection eles)`:从`index`位置开始将`eles`中的所有元素添加进来
- **`Object get(int index)`:获取指定`index`位置的元素**
- `int indexOf(Object obj)`:返回obj在集合中首次出现的位置，如果找不到返回-1。
- `int lastIndexOf(Object obj)`:返回obj在当前集合中末次出现的位置
- **`Object remove(int index)`:移除指定index位置的元素，并返回此元素**。
  - 注意父类`Collection`也有一个方法是 `boolean remove(Object obj)` 
    - 通过元素的`equals`方法判断是否是要删除的那个元素。只会删除找到的第一个元素。
  - 所以List类可以按索引或者对象来删除。
- **`Object set(int index, Object ele)`:设置指定index位置的元素为ele**
- `List subList(int fromIndex, int toIndex)`:返回从fromIndex到toIndex位置的子集合（左闭右开区间）
  - 本身list不会改变。



## ArrayList

- ArrayList是List 接口的典型实现类、主要实现类
- 本质上，ArrayList是对象引用的一个”变长”数组，`Object[] elementData`

![image-20201224234807501](https://raw.githubusercontent.com/SaulJWu/images/main/20201224234807.png)

> ArrayList的JDK1.8之前与之后的实现区别？

- JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组
- JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组



> `Arrays.asList(...)` 方法返回的List 集合，既不是ArrayList实例，也不是Vector 实例。`Arrays.asList(...)`  返回值是一个固定长度的List 集合

![image-20201224234939047](https://raw.githubusercontent.com/SaulJWu/images/main/20201224234939.png)



### 源码分析

#### **JDK7：**

在jdk7时，空参实例化方式：

```java
ArrayList list = new ArrayList();
```

空参实例化时，底层是创建了长度是10的`Object[] elementData`。

**添加元素：**

添加元素时，在添加之前先确认容量是否够，不够就扩容，库容调用`ensureCapacityInternal(size + 1)`方法，`size`是原来的容量，调用`grow`方法，默认情况下，容量扩容为原来的**1.5倍**，特殊情况会将容量设置为要添加元素的容量，极端情况，容量设置为整型最大值，如果容量还不够就报超出内存异常`OutOfmemoryError()`。

扩容完以后，将原来数组中的元素拷贝过去。

**结论：建议开发中使用带参的构造器：`ArrayList list = new ArrayList(int initialCapacity)`，直接设置容量空间，避免扩容，效率会更高。**



#### **JKD8：**

先看空参构造器：

```java
ArrayList list = new ArrayList();
```

空参实例化时，底层`Object[] elementData`初始化为`{}`，并没有创建长度为10的数组，

**添加元素：**

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
```

添加元素时，第一次调用时，底层才创建了长度为10的数组，集合的索引指向这个元素，后续的添加和库容操作与JDK7无异。



#### **小结：**

**jdk7中的ArrayList的对象的创建类似于单例的饿汉式，实例化时先创建数组，有元素进来集合时就用索引指向元素。**

**而JKD8中的ArrayList的对象的创建类似于单例的懒汉式，实例化时不创建数组，延迟了数组的创建，节省内存。等有元素进来集合时才创建数组，并将索引指向元素。**





### 面试题

下面输出结果是？

```java
@Test
public void test1() {
    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    updateList(list);
    System.out.println(list);
}

private static void updateList(List list) {
    list.remove(2);
}
```

输出结果：

```
[1, 2]
```

这道题考的是按索引删除还是对象删除。

这里remove是调用`Object remove(int index)`方法，而不是`boolean remove(Object obj)` 方法。

如果想要按Object删除，要传一个对象进去

```java
list.remove(new Integer(2))
```



## LinkedList

- 对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高

- 底层使用**双向链表**存储，内部没有声明数组，而是定义了内部类，内部类为`Node`类型的`first`和`last`，用于记录首末元素。同时，定义内部类`Node`，作为`LinkedList`中保存数据的基本结构。`Node`除了保存数据，还定义了两个变量：
  - `prev`变量记录前一个元素的位置
  - `next`变量记录下一个元素的位置



### 源码分析

#### 构造器

先看空参的构造器：

```
LinkedList list = new LinkedList();
```

空参实例化时，内部声明了Node类型的first和last属性，默认值为null。size=0，modCount=0。



#### 添加元素

当追加元素时，调用`add`方法：

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}
```

而`add`方法里会调用`linkLast`方法

```java
void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
```

我们解析一下这段代码：

- 声明`l节点`是当前集合的`last`属性指向的节点，也就是上次最后的节点。
- 调用Node`的`实例化方法，把(`l节点`，`新节点`和`null`)做为参数，调用`Node`的构造器创建节点对象。
- `last`属性指向`新节点`
- 如果`l节点`是空的话，`first`属性指向新节点。否则`l节点`的`next`属性指向`新节点`。
- `size`和`modCount`都自增。



下面是创建Node对象定义方式：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

这时如果是第一次追加元素，`linkLast`方法调用`Node`对象的构造器，实际上参数为：(`l节点`,`新节点`,`null`)，l节点是上次的最后节点，即null，会将当前对象的`first`和`last`属性指向`null`。

如果不是第一次追加元素，`linkLast`调用`Node`对象的构造器，实际上参数为：(`l节点`,`新节点`,`null`)，，l节点是上次的最后后节点，并且`prev`变量记录前一个元素的位置，`next`变量记录下一个元素的位置。



看到这里，你就明白为什么是双向链表，每个元素，也就是节点，每次实例化时都有`prev`和`next`属性指向某个元素或null，分别指向前后节点，`first`和`last`都记录当前集合的首末元素。无论新增还是插入元素，只要改变指向就行了，所以当频繁的插入和删除元素时比`ArrayList`效率高很多。

如果是`ArrayList`节点在中间插入元素，还得让后面的元素挪位，重新指向。

假设`ArrayList`集合里有1万个元素，我要从第三个位置插入，那集合的操作就很多了，后面每个元素都要挪位，这样子效率就很低了。

如果这是`LinkeList`集合，只需要移动指针，需要做的操作是：

- 将第二个元素的next指针指向要插入的元素
- 要插入的元素的prev指针指向第二个元素
- 要插入的元素的next指针指向第四个元素
- 第四个元素的prev指针指向要插入的元素



#### get和set方法

先源码：

- get

```java
public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}
```

- set

```java
public E set(int index, E element) {
    checkElementIndex(index);
    Node<E> x = node(index);
    E oldVal = x.item;
    x.item = element;
    return oldVal;
}
```

- get和set方法都需要node方法来返回对象。

```java
Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

这里很明显，当LinkedList随机get/set元素时，都需要从集合的首元素或者末元素开始，一个个遍历去找到想要寻找的元素，所以这里相对效率就低了。

而ArrayList集合底层是一个动态数组，直接通过下标就可以设置或者获取到元素了，所以在get和set方面，相对效率就高。

- ArrayList的get和set方法

```java
public E get(int index) {
    rangeCheck(index);

    return elementData(index);
}
```

```java
public E set(int index, E element) {
    rangeCheck(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}
```

```java
E elementData(int index) {
    return (E) elementData[index];
}
```



### 新增方法

- `void addFirst(Object obj)`
- `void addLast(Object obj)`
- `Object getFirst()`
- `Object getLast()`
- `Object removeFirst()`
- `Object removeLast()`



## Vector

- 底层使用`Object[] elementData` 存储
- `Vector` 是一个古老的集合，JDK1.0就有了。大多数操作与`ArrayList`相同，区别之处在于`Vector`是线程安全的。`Vector`很多方法都是用了同步方法`synchronized`。
- 在各种`list`中，最好把`ArrayList`作为缺省选择。当插入、删除频繁时，使用`LinkedList`；`Vector`因为很多都是同步方法总是比ArrayList慢，所以尽量避免使用。

![image-20201224234856011](https://raw.githubusercontent.com/SaulJWu/images/main/20201224234856.png)

### 源码分析

JDK7和8的Vector基本上没区别。

先看构造器：

```java
public Vector() {
    this(10);
}

public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}

public Vector(int initialCapacity, int capacityIncrement) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    this.elementData = new Object[initialCapacity];
    this.capacityIncrement = capacityIncrement;
}
```

也是跟JDK7的`ArrayList`一样，一上来就创建了长度是10的`Object[] elementData`。



添加元素：

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
```

```java
private void ensureCapacityHelper(int minCapacity) {
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}
```

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

添加元素时，如果要扩容就将默认将容量库容为原来的2倍。



### 新增方法：

- `void addElement(Object obj)`
- `void insertElementAt(Object obj,intindex)`
- `void setElementAt(Object obj,intindex)`
- `void removeElement(Object obj)`
- `void removeAllElements()`



## 面试题

> 请问`ArrayList`/`LinkedList`/`Vector`的异同？谈谈你的理解？`ArrayList`底层是什么？扩容机制？`Vector`和`ArrayList`的最大区别?

**ArrayList和LinkedList的异同**

- 二者都线程不安全，相对线程安全的`Vector`，执行效率高。

- 此外，`ArrayList`是实现了基于动态数组的数据结构，`LinkedList`基于链表的数据结构。

- 对于随机访问`get`和`set`，`ArrayList`优于`LinkedList`，因为`LinkedList`要移动指针。

- 对于新增和删除操作`add(特指插入)`和`remove`，`LinkedList`比较占优势，因为`ArrayList`要移动数据。



**ArrayList和Vector的区别**

- `Vector`和`ArrayList`几乎是完全相同的,唯一的区别在于`Vector`是同步类(`synchronized`)，属于强同步类。因此开销就比`ArrayList`要大，访问要慢。

- 正常情况下,大多数的Java程序员使用`ArrayList`而不是`Vector`,因为同步完全可以由程序员自己来控制。
- **`Vector`每次扩容请求其大小的2倍空间，而`ArrayList`是1.5倍。**
- `Vector`还有一个子类`Stack`。

## 总结

> `ArrayList`、`LinkedList`和`Vector`三者的异同

**同：**

- 三各类都是实现了List接口， 存储数据的特点相同：存储有序的、可重复的数据。

**不同：**

- `ArrayList`：作为List接口的主要实现类，线程不安全的，效率高；底层使用**动态数组**存储
- `LinkedList`：对于频繁的插入、删除操作，使用此类比`Arraylist`效率高；底层使用双向链表存储
- `Vector`：作为List接口的古老实现类，线程安全的，效率低；底层使用**动态数组**存储



> **常用方法**

- 增：`add(Object obj)`
- 删：`remove(int index)` / `remove(Object obj)`
- 改：`set(int index, Object ele)`
- 查：`get(int index)`
- 插：`add(int index,Object obj)`
- 长度：`size()`
- 遍历：
  - 1、`Iterator`迭代器
  - 2、增强`for`循环
  - 3、普通`for`循环