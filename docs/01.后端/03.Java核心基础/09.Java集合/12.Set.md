---
title: Set
date: 2020-12-25 22:48:33
permalink: /pages/e71592/
categories:
  - 后端
  - Java核心基础
  - Java集合
tags:
  - Set
  - HashSet
  - LinkedHashSet
  - TreeSet
---
## 前言

`Java` 集合可分为`Collection` 和`Map` 两种体系:

- `Collection`接口：单列数据，定义了存取一组对象的方法的集合
  - `List`：元素有序、可重复的集合
    - `ArrayList`、`LinkedList`、`Vector`
  - `Set`：元素无序、不可重复的集合
    - `HashSet`、`LinkedHashSet`、`TreeSet`
- `Map`接口：双列数据，保存具有映射关系“`key-value对`”的集合，也称为**键值对**。
  - `HashMap`、`LinkedHashMap`、`TreeMap`、`Hashtable`、`Properties` 



**上一篇我们学习了List接口，接下来学习Set接口**



## 概述

- `Set`接口是`Collection`的子接口，set接口没有提供额外的方法
- `Set` 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个`Set` 集合中，则添加操作失败。
- `Set` 判断两个对象是否相同不是使用`==`运算符，而是根据`equals()` 方法

**结论：Set存储无序的、不可重复的数据。**

## HashSet

### 概述

- HashSet是Set 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。

- HashSet按Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。

### 特点

HashSet具有以下特点：

- 不能保证元素的排列顺序
- HashSet不是线程安全的
- 集合元素可以是`null`



**HashSet 集合判断两个元素相等的标准：**两个对象通过`hashCode()` 方法比较相等，并且两个对象的`equals()` 方法返回值也相等。

对于存放在Set容器中的对象，**对应的类一定要重写`equals()`和`hashCode(Object obj)`方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”。**



### 无序性

> 如何体现无序性？

```java
@Test
public void test1() {
    HashSet set = new HashSet();
    set.add(456);
    set.add(123);
    set.add("AA");
    set.add("CC");
    set.add(129);
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

**无序性不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。**

至于哈希值等下再说。



### 不可重复性

```java
@Test
public void test1() {
    HashSet set = new HashSet();
    set.add(456);
    set.add(123);
    //相同元素
    set.add(123);
    set.add("AA");
    set.add("CC");
    set.add(129);
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

当你尝试添加相同元素，输出时发现相同元素并没有添加成功。

> 为什么了更深入提现不可重复性，接下来我们用一个对象来说明。

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person() {
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

注意这时我并没有重写`equals`方法，接下来测试一下，到底有几个对象：

```java
@Test
public void test2() {
    HashSet set = new HashSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

你会发现，你居然成功在set中添加了2个对象，这是为什么？

因为我们确实都是在堆内存中新建2个对象，它们的内存地址不一样，Set自然是，那么我现在重写`equals`方法，再测试一下：

直接让idea生成，先注释掉hashCode方法

```java
@Override
public boolean equals(Object o) {
    //为了更加直观，看看到底有没有调用equals方法
    System.out.println("equals方法被调用了……");
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Person person = (Person) o;

    if (age != person.age) return false;
    return name != null ? name.equals(person.name) : person.name == null;
}
```

这时再运行一次测试案例：

```java
@Test
public void test2() {
    HashSet set = new HashSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

输出结果：

```
Person{name='Tom', age=12}
Person{name='Tom', age=12}
```

并没有调用equals方法，这是为什么？不急，先把hashCode方法取消注释，这时再测试一次。

```java
@Override
public int hashCode() {
    //为了更加直观，看看到底有没有调用hashCode方法
    System.out.println("hashCode被调用了……");
    int result = name != null ? name.hashCode() : 0;
    result = 31 * result + age;
    return result;
}
```

运行测试案例，输出结果：

```
hashCode被调用了……
hashCode被调用了……
equals方法被调用了……
Person{name='Tom', age=12}
```

这时发现hashCode方法被调用了2次，equals方法调用了一次，而且集合也提现了不可重复性，那么底层到底发生了什么事情？

> 如果你自己来设计一个HashSet，该怎么确保不可重复性？

比如第一次添加，什么元素都没有，直接添加。

第二次添加元素，跟第一个元素比较（调用equals方法），如果不相等，才添加。

第三次添加元素，跟第一和第二个元素比较（调用equals方法），如果都不相等，才添加。

……

第1000次添加元素，岂不是要跟前面999个元素比较？这样子效率未免太低了，接下来我们看看HashSet的底层源码。



### 底层原理

当你点开HashSet的构造方法，发现底层是一个`HashMap`，而点开`HashMap`构造方法，而HashMap是由key和value键值对组成的Node类，其中key是我们指定的对象，value是HashSet自定义的一个类。

```java
public HashSet() {
    map = new HashMap<>();
}
```

```java
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
```

```java
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

节点由Node类实现，这是HashMap中的内部类，有以下四个参数：

> - final int hash;  节点hash值
> - final K key;   节点的key
> - V value;     节点的value
> - Node<K,V> next; 该节点的下一节点

当HashSet使用HashMap实现时，指定元素将保存在Node的key中，而value是HashSet自定义的一个对象。



> 向HashSet中添加元素的过程：

- 当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据hashCode值，通过某种散列函数决定该对象在HashSet**底层数组**中的存储位置。
  - （这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）
  - HashMap根据元素hash值决定元素在哪个链表，算法是：**(n-1)&hash**。其中n是数组长度，hash是元素Hash值，得到的结果就是HashMap中数组的下标，也就决定了元素属于哪个链表。这个算法说白了就是元素Hash值除以数组长度（注意不是除以数组长度减一）然后取余
- 如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果为false，那么会保存该元素，但是该数组的位置已经有元素了（**可能不止一个**），那么会通过**链表的方式**继续链接。
  - JDK7往该数组的位置的最上面链接。
  - JDK8往该数组的位置的最下面链接。
  - 一句话：七上八下。



![image-20201226200325496](C:\Users\SaulJ\AppData\Roaming\Typora\typora-user-images\image-20201226200325496.png)



**注意：**

如果两个元素的equals() 方法返回true，但它们的hashCode() 返回值不相等，hashSet将会把它们存储在不同的位置，但依然可以添加成功。因为hashSet是先调用hashCode()方法，后调用equals方法。





**小结：**

**HashSet底层：数组+链表的结构。**



### hashCode()

哈希值在这里就是为了不用一个个比较，只有2个对象的哈希值相等时，才会去调用equals方法，这样子效率大大提高了。

所以就算是哈希值相等的2个对象，不代表2个对象属性一定相等，具体是否相等，还需要equals方法来判断。

> 重写hashCode() 方法的基本原则

- 在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。
- 当两个对象的equals() 方法比较返回true 时，这两个对象的hashCode() 方法的返回值也应相等。
- 对象中用作equals() 方法比较的Field，都应该用来计算hashCode 值。



> 以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？

- 选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）
- 并且31只占用5bits,相乘造成数据溢出的概率较小。
- 31可以由i*31== (i<<5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）
- 31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)



不太明白？来举例子：

```java
@Override
public int hashCode() {
    //为了更加直观，看看到底有没有调用hashCode方法
    System.out.println("hashCode被调用了……");
    int result = name != null ? name.hashCode() : 0;
    result = 31 * result + age;
    return result;
}
```

这是刚才idea生成的hashCode方法，假设将`result = 31 * result + age;`改为`result = result + age;`，会发生什么事情？

我们已经知道在HashSet中，hashCode只是决定存放位置，假设有一个对象的返回值是：20+24 = 44，第二个对象是：24 + 20 = 44，它们的哈希值相同，所以将会调用equals方法，所以31只是为了降低哈希值相等的概率，不用去调用equals方法，提高效率。



### equals()

> **重写equals() 方法的基本原则：**

以自定义的Person类为例，何时需要重写equals()？

- 当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。
- 因此，违反了“相等的对象必须具有相等的散列码”。
- 结论：复写equals方法的时候一般都需要同时复写hashCode方法。**通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。**



## LinkedHashSet

- LinkedHashSet是HashSet的子类
- **LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。**
- LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。
- LinkedHashSet不允许集合元素重复。



这么看来LinkedHashSet和HashSet的底层都差不多，只是用了双向链表来指向元素的位置。

> 什么时候维护元素的次序？

在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个元素和后一个元素。所以LinkedHashSet插入性能略低于HashSet。

比如：

![image-20201226202605110](https://raw.githubusercontent.com/SaulJWu/images/main/20201226202605.png)

AA是第一个添加的，所以前一个元素为null，后面一个元素是456……



既然LinkedHashSet知道了元素的位置，那么遍历的时候，也就是迭代访问Set 里的全部元素时有很好的性能。



## TreeSet

### 概述

- TreeSet是`SortedSet`接口的实现类，`TreeSet`可以确保集合元素处于排序状态。
- **TreeSet基于`TreeMap`实现，底层使用`红黑树`结构存储数据。**
- TreeSet只能存储相同类型的对象。
- TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。



### 底层结构

- TreeSet和后面要讲的TreeMap采用红黑树的存储结构
- 特点：有序，查询速度比List快

![image-20201226210408937](https://raw.githubusercontent.com/SaulJWu/images/main/20201226210409.png)

**说明：**

假设使用数字来代表一个对象，比18小的都放左边，比18大的对象放右边。

所以14是在18的左边，22在18的右边。

接下来TreeSet添加了10，比18小，所以肯定在18的左边里面，那么18的左边里面，又比14小，所以放在14的左边。

TreeSet添加了15，比18小，所以肯定在18的左边里面，那么18的左边里面，又比14大，所以放在14的右边。

TreeSet添加了8，比18小，所以肯定在18的左边里面，那么18的左边里面，又比10小，所以放在10的左边

……

**这就是红黑树结构，也叫二叉查找树。**

8也比15小啊，为什么没有放在15的左边，这里涉及了红黑树底层，以后会讲到，目前只需要了解什么是红黑树结构。







> 测试案例

我们来尝试添加多个不同类型的元素看看：

```java
@Test
public void test3() {
    TreeSet set = new TreeSet();
    set.add(123);
    set.add(456);
    set.add("AA");
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

结果：

```
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
```

说明TreeSet只能存储相同类型的对象。

> 试试相同类型是否能存储以及它的排序。

```java
@Test
public void test3() {
    TreeSet set = new TreeSet();
    set.add(123);
    set.add(456);
    set.add(33);
    set.add(65);
    set.add(-55);
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

结果：

```
-55
33
65
123
456
```

发现它能存储了，而且是从小到大排序的。

> 试试自定义类型的对象的排序

```java
@Test
public void test4() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Jerry", 32));
    set.add(new Person("Jim", 2));
    set.add(new Person("Mike", 65));
    set.add(new Person("Jack", 74));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

结果程序报错：

```
java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable

	at java.util.TreeMap.compare(TreeMap.java:1294)
	at java.util.TreeMap.put(TreeMap.java:538)
	at java.util.TreeSet.add(TreeSet.java:255)
```

发现它要调用对象的Comparable接口，而实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。

### 排序	

#### 自然排序

- TreeSet会调用集合元素的compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列
- **如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口。**
  - 实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。
  - **自然排序中，比较2个对象是否相同的标准：compareTo(Object obj) 方法返回0，不再是equals方法。**
- Comparable 的典型实现：
  - BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较
  - Character：按字符的unicode值来进行比较
  - Boolean：true 对应的包装类实例大于false 对应的包装类实例
  - String：按字符串中字符的unicode 值进行比较
  - Date、Time：后边的时间、日期比前面的时间、日期大。



既然这样，上面案例我就得把Person类实现Comparable 接口，并且compareTo方法就可以了。

> 先只比较一个属性，试试刚才的测试案例

- 按照姓名从小到大排列

```java
@Override
public int compareTo(Object o) {
    if (o instanceof Person) {
        Person person = (Person) o;
        return this.name.compareTo(person.name);
    }
    throw new RuntimeException("对象类型不一致……");
}
```

- 测试案例

```java
@Test
public void test4() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Jerry", 32));
    set.add(new Person("Jim", 2));
    set.add(new Person("Mike", 65));
    set.add(new Person("Jack", 74));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 输出结果

```
Person{name='Jack', age=74}
Person{name='Jerry', age=32}
Person{name='Jim', age=2}
Person{name='Mike', age=65}
Person{name='Tom', age=12}
```

确实也实现了我们的需求。

> 接下来试试2个相同名字的对象

- 测试案例

```java
@Test
public void test5() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Tom", 52));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 输出结果

```
Person{name='Tom', age=12}
```

发现只添加了第一个对象，第二个对象没有添加成功

> 把另一个属性也放入compareTo中

- 年龄从小到大排列

```java
@Override
public int compareTo(Object o) {
    if (o instanceof Person) {
        Person person = (Person) o;
        int compare = this.name.compareTo(person.name);
        return compare == 0 ? Integer.compare(this.age, person.age) : compare;
    }
    throw new RuntimeException("对象类型不一致……");
}
```

- 测试案例

```java
@Test
public void test5() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 52));
    set.add(new Person("Tom", 42));
    set.add(new Person("Tom", 32));
    set.add(new Person("Tom", 72));
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 结果

```
Person{name='Tom', age=12}
Person{name='Tom', age=32}
Person{name='Tom', age=42}
Person{name='Tom', age=52}
Person{name='Tom', age=72}
```

这就实现了自然排序，除非2个对象的name和age都相等，否则就算是不是同一个对象。

**自然排序中，比较2个对象是否相同的标准：`compareTo(Object obj)` 方法返回0，不再是`equals`方法。**



#### 定制排序

- TreeSet的自然排序要求元素所属的类实现`Comparable`接口，如果元素所属的类没有实现`Comparable`接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过`Comparator`接口来实现。需要重写`compare(T o1,T o2)`方法。
- 利用`int compare(T o1,T o2)`方法，比较o1和o2的大小：
  - 如果方法返回正整数，则表示o1大于o2；
  - 如果返回0，表示相等；
  - 返回负整数，表示o1小于o2。
- 要实现定制排序，需要将实现`Comparator`接口的实例作为形参传递给TreeSet的构造器。
- 此时，**仍然只能向`TreeSet`中添加类型相同的对象**。否则发生`ClassCastException`异常。
- **定制排序中，判断两个元素相等的标准是：通过`Comparator`比较两个元素返回了0。**



> 具体实现

```java
@Test
public void test6() {
    Comparator comparator = new Comparator() {
        //按照年龄从大到小排列
        @Override
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Person && o2 instanceof Person) {
                Person p1 = (Person) o1;
                Person p2 = (Person) o2;
                int result = -Integer.compare(p1.getAge(), p2.getAge());
                return result == 0 ? p1.getName().compareTo(p2.getName()) : result;
            }
            throw new RuntimeException("数据类型不是Person……");
        }
    };
    //把comparator接口放入TreeSet中
    TreeSet set = new TreeSet(comparator);
    set.add(new Person("Tom", 52));
    set.add(new Person("Tom", 42));
    set.add(new Person("Tom", 32));
    set.add(new Person("Tom", 72));
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 结果

```
Person{name='Tom', age=72}
Person{name='Tom', age=52}
Person{name='Tom', age=42}
Person{name='Tom', age=32}
Person{name='Tom', age=12}
```

虽然Person类中，自带将年龄从小到大排列的compareTo方法，但是这次TreeSet实例化时，用了`Comparator`的具体实现，所以是优先按Comparator的`compare(Object o1, Object o2)` 方法，年龄自然是从大到小排序。

记得要比较全部属性，不然相同年龄的2个人，就会按照先来后到的方式，后面来的元素就添加失败了。



### 新增方法

- `Comparator comparator()`
- `Object first()`
- `Object last()`
- `Object lower(Object e)`
- `Object higher(Object e)`
- `SortedSet subSet(fromElement, toElement)`
- `SortedSet headSet(toElement)`
- `SortedSet tailSet(fromElement)`

因为TreeSet其实开发中用得很少，这里就不展开了说明了，日后需要用到参考API即可。



## 面试题

下面输出结果是？

![image-20201226213211939](https://raw.githubusercontent.com/SaulJWu/images/main/20201226213212.png)

```
remove p1 后：[Person{id=1002, name='BB'}, Person{id=1001, name='CC'}]

重新添加后：[Person{id=1002, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='CC'}]

最后：[Person{id=1002, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='CC'}, Person{id=1001, name='AA'}]
```

为什么p1没移除成功？

以下是java.util.HashSet.remove()方法的声明。

```java
public boolean remove(Object o)
```

我们打印一下移除结果，返回false，这是为什么？

**HashSet 集合判断两个元素相等的标准：**两个对象通过`hashCode()` 方法比较相等，并且两个对象的`equals()` 方法返回值也相等。

当HashSet使用HashMap实现时，指定元素将保存在Node的key中，而value是HashSet自定义的一个对象，元素的哈希值会保存在节点的hash属性中。

当改变了p1的名字后，HashSet就无法判断这两个元素相等了。所以就remove失败。(虽然遍历还是能指向这个元素，能获取修改后的值)

**当已经添加到HashMap中的对象改变了hash值后，不会改变它在HashMap中的位置，此时元素的Hash值和节点的Hash值会不同。**

**HashSet删除时会根据要删除元素的哈希值，去找到节点相同哈希值的对象，但是我们已经修改了元素的哈希值，所以肯定找不到，所以就返回false，删除失败。**

下面准备开始执行remove()方法，看一下HashMap的remove()方法代码：

~~~java
@Override
public boolean remove(Object key, Object value) {
    return removeNode(hash(key), key, value, true, true) != null;
}
~~~

调用了removeNode()方法：

~~~java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {
        Node<K,V> node = null, e; K k; V v;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
~~~



> 最快方式去除List内的重复元素

~~~java
public List removeDuplicateElements(List list){
    HashSet set = new HashSet();
    set.addAll(list);
    return new ArrayList(set);
}
~~~



## 总结

- Set接口：存储无序的、不可重复的数据
  - `HashSet`实现类：作为`Set`接口的主要实现类；线程不安全的；可以存储`null`值。**底层是数组+链表。**
    - `LinkedHashSet`实现类：作为`HashSet`的子类；遍历其内部数据时，可以按照添加的顺序遍历。**底层是数组+双向链表。**
  - `TreeSet`实现类：可以按照添加对象的指定属性，进行排序。**底层是红黑树。**