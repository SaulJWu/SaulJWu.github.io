---
title: Set
date: 2020-12-25 22:48:33
permalink: /pages/e71592/
categories:
  - 后端
  - Java核心基础
  - Java集合
tags:
  - Set
  - HashSet
  - LinkedHashSet
  - TreeSet
---
## 前言

`Java` 集合可分为`Collection` 和`Map` 两种体系:

- `Collection`接口：单列数据，定义了存取一组对象的方法的集合
  - `List`：元素有序、可重复的集合
    - `ArrayList`、`LinkedList`、`Vector`
  - `Set`：元素无序、不可重复的集合
    - `HashSet`、`LinkedHashSet`、`TreeSet`
- `Map`接口：双列数据，保存具有映射关系“`key-value对`”的集合，也称为**键值对**。
  - `HashMap`、`LinkedHashMap`、`TreeMap`、`Hashtable`、`Properties` 



**接下来学习Set接口**



## 概述

- `Set`接口是`Collection`的子接口，set接口没有提供额外的方法
- `Set` 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个`Set` 集合中，则添加操作失败。
- `Set` 判断两个对象是否相同不是使用`==`运算符，而是根据`equals()` 方法

**结论：Set存储无序的、不可重复的数据。**



## LinkedHashSet

- LinkedHashSet是HashSet的子类
- **LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。**
- LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。
- LinkedHashSet不允许集合元素重复。



这么看来LinkedHashSet和HashSet的底层都差不多，只是用了双向链表来指向元素的位置。

> 什么时候维护元素的次序？

在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个元素和后一个元素。所以LinkedHashSet插入性能略低于HashSet。

比如：

![image-20201226202605110](https://raw.githubusercontent.com/SaulJWu/images/main/20201226202605.png)

AA是第一个添加的，所以前一个元素为null，后面一个元素是456……



既然LinkedHashSet知道了元素的位置，那么遍历的时候，也就是迭代访问Set 里的全部元素时有很好的性能。



## TreeSet

### 概述

- TreeSet是`SortedSet`接口的实现类，`TreeSet`可以确保集合元素处于排序状态。
- **TreeSet基于`TreeMap`实现，底层使用`红黑树`结构存储数据。**
- TreeSet只能存储相同类型的对象。
- TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。



### 底层结构

- TreeSet和后面要讲的TreeMap采用红黑树的存储结构
- 特点：有序，查询速度比List快

![image-20201226210408937](https://raw.githubusercontent.com/SaulJWu/images/main/20201226210409.png)

**说明：**

假设使用数字来代表一个对象，比18小的都放左边，比18大的对象放右边。

所以14是在18的左边，22在18的右边。

接下来TreeSet添加了10，比18小，所以肯定在18的左边里面，那么18的左边里面，又比14小，所以放在14的左边。

TreeSet添加了15，比18小，所以肯定在18的左边里面，那么18的左边里面，又比14大，所以放在14的右边。

TreeSet添加了8，比18小，所以肯定在18的左边里面，那么18的左边里面，又比10小，所以放在10的左边

……

**这就是红黑树结构，也叫二叉查找树。**

8也比15小啊，为什么没有放在15的左边，这里涉及了红黑树底层，以后会讲到，目前只需要了解什么是红黑树结构。







> 测试案例

我们来尝试添加多个不同类型的元素看看：

```java
@Test
public void test3() {
    TreeSet set = new TreeSet();
    set.add(123);
    set.add(456);
    set.add("AA");
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

结果：

```
java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
```

说明TreeSet只能存储相同类型的对象。

> 试试相同类型是否能存储以及它的排序。

```java
@Test
public void test3() {
    TreeSet set = new TreeSet();
    set.add(123);
    set.add(456);
    set.add(33);
    set.add(65);
    set.add(-55);
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

结果：

```
-55
33
65
123
456
```

发现它能存储了，而且是从小到大排序的。

> 试试自定义类型的对象的排序

```java
@Test
public void test4() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Jerry", 32));
    set.add(new Person("Jim", 2));
    set.add(new Person("Mike", 65));
    set.add(new Person("Jack", 74));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

结果程序报错：

```
java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable

	at java.util.TreeMap.compare(TreeMap.java:1294)
	at java.util.TreeMap.put(TreeMap.java:538)
	at java.util.TreeSet.add(TreeSet.java:255)
```

发现它要调用对象的Comparable接口，而实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。

### 排序	

#### 自然排序

- TreeSet会调用集合元素的compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列
- **如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口。**
  - 实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。
  - **自然排序中，比较2个对象是否相同的标准：compareTo(Object obj) 方法返回0，不再是equals方法。**
- Comparable 的典型实现：
  - BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较
  - Character：按字符的unicode值来进行比较
  - Boolean：true 对应的包装类实例大于false 对应的包装类实例
  - String：按字符串中字符的unicode 值进行比较
  - Date、Time：后边的时间、日期比前面的时间、日期大。



既然这样，上面案例我就得把Person类实现Comparable 接口，并且compareTo方法就可以了。

> 先只比较一个属性，试试刚才的测试案例

- 按照姓名从小到大排列

```java
@Override
public int compareTo(Object o) {
    if (o instanceof Person) {
        Person person = (Person) o;
        return this.name.compareTo(person.name);
    }
    throw new RuntimeException("对象类型不一致……");
}
```

- 测试案例

```java
@Test
public void test4() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Jerry", 32));
    set.add(new Person("Jim", 2));
    set.add(new Person("Mike", 65));
    set.add(new Person("Jack", 74));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 输出结果

```
Person{name='Jack', age=74}
Person{name='Jerry', age=32}
Person{name='Jim', age=2}
Person{name='Mike', age=65}
Person{name='Tom', age=12}
```

确实也实现了我们的需求。

> 接下来试试2个相同名字的对象

- 测试案例

```java
@Test
public void test5() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 12));
    set.add(new Person("Tom", 52));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 输出结果

```
Person{name='Tom', age=12}
```

发现只添加了第一个对象，第二个对象没有添加成功

> 把另一个属性也放入compareTo中

- 年龄从小到大排列

```java
@Override
public int compareTo(Object o) {
    if (o instanceof Person) {
        Person person = (Person) o;
        int compare = this.name.compareTo(person.name);
        return compare == 0 ? Integer.compare(this.age, person.age) : compare;
    }
    throw new RuntimeException("对象类型不一致……");
}
```

- 测试案例

```java
@Test
public void test5() {
    TreeSet set = new TreeSet();
    set.add(new Person("Tom", 52));
    set.add(new Person("Tom", 42));
    set.add(new Person("Tom", 32));
    set.add(new Person("Tom", 72));
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 结果

```
Person{name='Tom', age=12}
Person{name='Tom', age=32}
Person{name='Tom', age=42}
Person{name='Tom', age=52}
Person{name='Tom', age=72}
```

这就实现了自然排序，除非2个对象的name和age都相等，否则就算是不是同一个对象。

**自然排序中，比较2个对象是否相同的标准：`compareTo(Object obj)` 方法返回0，不再是`equals`方法。**



#### 定制排序

- TreeSet的自然排序要求元素所属的类实现`Comparable`接口，如果元素所属的类没有实现`Comparable`接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过`Comparator`接口来实现。需要重写`compare(T o1,T o2)`方法。
- 利用`int compare(T o1,T o2)`方法，比较o1和o2的大小：
  - 如果方法返回正整数，则表示o1大于o2；
  - 如果返回0，表示相等；
  - 返回负整数，表示o1小于o2。
- 要实现定制排序，需要将实现`Comparator`接口的实例作为形参传递给TreeSet的构造器。
- 此时，**仍然只能向`TreeSet`中添加类型相同的对象**。否则发生`ClassCastException`异常。
- **定制排序中，判断两个元素相等的标准是：通过`Comparator`比较两个元素返回了0。**



> 具体实现

```java
@Test
public void test6() {
    Comparator comparator = new Comparator() {
        //按照年龄从大到小排列
        @Override
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Person && o2 instanceof Person) {
                Person p1 = (Person) o1;
                Person p2 = (Person) o2;
                int result = -Integer.compare(p1.getAge(), p2.getAge());
                return result == 0 ? p1.getName().compareTo(p2.getName()) : result;
            }
            throw new RuntimeException("数据类型不是Person……");
        }
    };
    //把comparator接口放入TreeSet中
    TreeSet set = new TreeSet(comparator);
    set.add(new Person("Tom", 52));
    set.add(new Person("Tom", 42));
    set.add(new Person("Tom", 32));
    set.add(new Person("Tom", 72));
    set.add(new Person("Tom", 12));
    Iterator iterator = set.iterator();
    while (iterator.hasNext()) {
        System.out.println(iterator.next());
    }
}
```

- 结果

```
Person{name='Tom', age=72}
Person{name='Tom', age=52}
Person{name='Tom', age=42}
Person{name='Tom', age=32}
Person{name='Tom', age=12}
```

虽然Person类中，自带将年龄从小到大排列的compareTo方法，但是这次TreeSet实例化时，用了`Comparator`的具体实现，所以是优先按Comparator的`compare(Object o1, Object o2)` 方法，年龄自然是从大到小排序。

记得要比较全部属性，不然相同年龄的2个人，就会按照先来后到的方式，后面来的元素就添加失败了。



### 新增方法

- `Comparator comparator()`
- `Object first()`
- `Object last()`
- `Object lower(Object e)`
- `Object higher(Object e)`
- `SortedSet subSet(fromElement, toElement)`
- `SortedSet headSet(toElement)`
- `SortedSet tailSet(fromElement)`

因为TreeSet其实开发中用得很少，这里就不展开了说明了，日后需要用到参考API即可。



## 面试题

下面输出结果是？

![image-20201226213211939](https://raw.githubusercontent.com/SaulJWu/images/main/20201226213212.png)

```
remove p1 后：[Person{id=1002, name='BB'}, Person{id=1001, name='CC'}]

重新添加后：[Person{id=1002, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='CC'}]

最后：[Person{id=1002, name='BB'}, Person{id=1001, name='CC'}, Person{id=1001, name='CC'}, Person{id=1001, name='AA'}]
```

为什么p1没移除成功？

以下是java.util.HashSet.remove()方法的声明。

```java
public boolean remove(Object o)
```

我们打印一下移除结果，返回false，这是为什么？

**HashSet 集合判断两个元素相等的标准：**两个对象通过`hashCode()` 方法比较相等，并且两个对象的`equals()` 方法返回值也相等。

当HashSet使用HashMap实现时，指定元素将保存在Node的key中，而value是HashSet自定义的一个对象，元素的哈希值会保存在节点的hash属性中。

当改变了p1的名字后，HashSet就无法判断这两个元素相等了。所以就remove失败。(虽然遍历还是能指向这个元素，能获取修改后的值)

**当已经添加到HashMap中的对象改变了hash值后，不会改变它在HashMap中的位置，此时元素的Hash值和节点的Hash值会不同。**

**HashSet删除时会根据要删除元素的哈希值，去找到节点相同哈希值的对象，但是我们已经修改了元素的哈希值，所以肯定找不到，所以就返回false，删除失败。**

下面准备开始执行remove()方法，看一下HashMap的remove()方法代码：

~~~java
@Override
public boolean remove(Object key, Object value) {
    return removeNode(hash(key), key, value, true, true) != null;
}
~~~

调用了removeNode()方法：

~~~java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {
        Node<K,V> node = null, e; K k; V v;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            if (p instanceof TreeNode)
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
~~~



> 最快方式去除List内的重复元素

~~~java
public List removeDuplicateElements(List list){
    HashSet set = new HashSet();
    set.addAll(list);
    return new ArrayList(set);
}
~~~



## 总结

- Set接口：存储无序的、不可重复的数据
  - `HashSet`实现类：作为`Set`接口的主要实现类；线程不安全的；可以存储`null`值。**底层是数组+链表。**
    - `LinkedHashSet`实现类：作为`HashSet`的子类；遍历其内部数据时，可以按照添加的顺序遍历。**底层是数组+双向链表。**
  - `TreeSet`实现类：可以按照添加对象的指定属性，进行排序。**底层是红黑树。**