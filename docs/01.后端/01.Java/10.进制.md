---
title: 进制
date: 2020-12-01 19:34:56
permalink: /pages/644fdb/
categories: 
  - 后端
  - Java
tags: 
  - 二进制
  - 十进制
  - 八进制
  - 十六进制
title: 进制
---



## 关于进制

所有数字在计算机底层都以**二进制**形式存在。



对于整数，有四种表示方式：

- 二进制(binary)

0，1，满2进1，以`0b`或`0B`开头

- 十进制(decimal)

0-9，满10进1。在生活中，我们用的是**十进制**。

- 八进制(octal)

0-7，满8进1，以数字0开头表示。

- 十六进制(hex)

0-A及A-F，满16进1，以`0x`或`0X`开头表示。此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0



## 进制关系表

| 十进制 | 十六进制 | 八进制 | 二进制 |
| ------ | -------- | ------ | ------ |
| 0      | 0        | 0      | 0      |
| 1      | 1        | 1      | 1      |
| 2      | 2        | 2      | 10     |
| 3      | 3        | 3      | 11     |
| 4      | 4        | 4      | 100    |
| 5      | 5        | 5      | 101    |
| 6      | 6        | 6      | 110    |
| 7      | 7        | 7      | 111    |
| 8      | 8        | 8      | 1000   |
| 9      | 9        | 11     | 1001   |
| 10     | A        | 12     | 1010   |
| 11     | B        | 13     | 1011   |
| 12     | C        | 14     | 1100   |
| 13     | D        | 15     | 1101   |
| 14     | E        | 16     | 1110   |
| 15     | F        | 17     | 1111   |
| 16     | 10       | 20     | 10000  |
| 17     | 11       | 21     | 10001  |



## 练习

~~~java
// - 二进制(binary) 0，1，满2进1，以`0b`或`0B`开头
int num1 = 0b110; // 6

// 十进制(decimal)
int num2 = 110; // 110

// - 八进制(octal) 0-7，满8进1，以数字0开头表示。
int num3 = 0127; // 87

// - 十六进制(hex) 0-A及A-F，满16进1，以`0x`或`0X`开头表示。此处的A-F不区分大小写。
int num4 = 0x110A; // 4362
~~~

发现输出结果都是以十进制形式输出。





## 二进制

- Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位
- 二进制的整数有如下三种形式：
  - 原码：直接将一个数值换成二进制数。最高位是符号位。
  - 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1.
  - 负数的补码：其反码加1。
- 计算机以二进制**补码**的形式保存所有的整数。
  - 正数的原码，反码，补码都相同
  - 负数的补码是其反码+1





## 二进制转换十进制

### 1110

比如存在一个二进制数字：1110。那么他十进制是多少？

- 第一种方法：

根据进制表关系，或者去推算：

| 二进制 | 十进制 |
| ------ | ------ |
| 10     | 2      |
| 100    | 4      |
| 1000   | 8      |

结果是14，那么有没有更简单的方法

- 第二种方法：

有，假设下面是内存空间

| 0      | 0    | 0    | 0    | 1     | 1     | 1     | 0    |
| ------ | ---- | ---- | ---- | ----- | ----- | ----- | ---- |
| 符号位 |      |      |      | 1*2^3 | 1*2^2 | 1*2^1 |      |

相加起来也是14。但是第二种方法只适用于原码。

> 符号位0表示整数，1表示负数。



### 1101110

比如存在一个二进制数：1101110，如何计算出十进制的实际值？

参考上个案例的第二种方法：

| 0    | 1     | 1     | 0    | 1     | 1     | 1     | 0    |
| ---- | ----- | ----- | ---- | ----- | ----- | ----- | ---- |
|      | 1*2^6 | 1*2^5 |      | 1*2^3 | 1*2^2 | 1*2^1 |      |

计算出结果是110。





### 10001110

那如果二进制数：10001110，十进制的实际值又是多少？

> 除了符号位，和上面二进制数1110（十进制14）,其他都一样

- 原码：


| 1    | 0    | 0    | 0    | 1     | 1     | 1     | 0    |
| ---- | ---- | ---- | ---- | ----- | ----- | ----- | ---- |
|      |      |      |      | 1*2^3 | 1*2^2 | 1*2^1 |      |

那么已经算出结果是14，因为符号位是1，所以最终结果是-14。





### 10111011

如果存在二进制的**补码**是10111011，那么它的十进制实际值是多少？

- 补码

| 1    | 0    | 1    | 1    | 1    | 0    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

- 反码：负数的补码是其反码+1，那么反码就是补码-1

| 1    | 0    | 1    | 1    | 1    | 0    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

- 原码：反码是原码的取反，除了符号位。

| 1    | 1        | 0    | 0    | 0    | 1       | 0    | 1       |
| ---- | -------- | ---- | ---- | ---- | ------- | ---- | ------- |
|      | 1*2^6=64 |      |      |      | 1*2^2=4 |      | 1*2^0=1 |

那么合计结果是69，符号位是1，所以是-69。通过计算机计算-69的补码也是10111011。



## 填坑

在精度损失案例2中，有一个小段代码

~~~java
int i2 = 128;
byte b = (byte)i2;// -128
~~~

为什么是-128呢？来分析一下。

> Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；

那么整数128的二进制数是：前面24个0 连上，1000 000。

| 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

那么当强转为byte时，占用8个字节空间，那么前面24个0也砍掉了，只剩下1000 0000



> 在二进制数中，首位是符号位，表示为负数。

那么此时变量也变成了负数，也就-128。



十进制转二进制