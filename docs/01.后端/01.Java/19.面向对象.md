---
title: 面向对象
date: 2020-12-08 15:00:41
permalink: /pages/ac3efa/
categories:
  - 后端
  - Java
tags:
  - 面向对象

---

## 学习路线

学习面向对象内容的三条主线：

1. **Java**类及类的成员：属性、方法、构造器、代码块、内部类
2. **面向对象的三大特征**：封装性、继承性、多态性、（抽象性）
3. **其它关键字**：this、super、static、final、abstract、interface、package、import

> 大处着眼，小处着手



## 面向过程与面向对象



### **何谓“面向对象”的编程思想？**

首先解释一下“思想”。

先问你个问题：你想做个怎样的人？

可能你会回答：我想做个好人，孝敬父母，尊重长辈，关爱亲朋……

你看，这就是思想。这是你做人的思想，或者说，是你做人的原则。

做人有做人的原则，编程也有编程的原则。这些编程的原则呢，就

是编程思想。



### 面向过程(`POP`) 与 面向对象(`OOP`)

- 二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。

- 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。

### **面向对象的三大特征**

- 封装 (`Encapsulation`)

- 继承 (`Inheritance`)

- 多态 (`Polymorphism`)

面向对象：Object Oriented Programming 

面向过程：Procedure Oriented Programming



### 面向过程例子

<img src="C:\Users\SaulJ\AppData\Roaming\Typora\typora-user-images\image-20201208151045123.png" alt="image-20201208151045123" style="zoom:50%;" />

### 面向过程例子

<img src="C:\Users\SaulJ\AppData\Roaming\Typora\typora-user-images\image-20201208151107241.png" alt="image-20201208151107241" style="zoom:50%;" />



### 面向对象的思想概述

- 程序员从面向过程的**执行者**转化成了面向对象的**指挥者**
- 面向对象分析方法分析问题的思路和步骤：
  - 根据问题需要，选择问题所针对的**现实世界中的实体**。 
  - 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了**概念世界中的类**。 
  - 把抽象的实体用计算机语言进行描述，**形成计算机世界中类的定义**。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。
  - 将**类实例化成计算机世界中的对象**。对象是计算机世界中解决问题的最终工具。

> 其实现在语言发展越来越快，只能说Java是具有面向对象特征的语言，不能说Java就是面向对象的语言。



### 练习1

**1.我要开车去丽江，这句话包含的类有什么？**

车，交通工具类

丽江，地点类



**2.体会以下几个经典案例涉及到的类。**

- 人在黑板上画圆

- 列车司机紧急刹车

- **售货员**统计收获**小票**的金额

- 你把**门**关上了



**3.抽象出下面系统中的“类”及其关系。**

![image-20201208152212262](https://raw.githubusercontent.com/SaulJWu/images/main/20201208152212.png)

名词就是类。

动词就是类的功能。





## 类和对象



### 面向对象的思想概述

- 面向对象的两个要素：类和对象。
- 类(Class)和对象(Object)是面向对象的核心概念。
  - 类是对一类事物的描述，是**抽象**的、概念上的定义
  - 对象是**实际存在**的该类事物的每个个体，因而也称为**实例(instance)**。 
- “万事万物皆对象”

![image-20201208152441648](https://raw.githubusercontent.com/SaulJWu/images/main/20201208152441.png)

可以理解为：**类 = 抽象概念的人；对象 = 实实在在的某个人**

面向对象程序设计的重点是**类的设计**

类的设计，**其实就是类的成员的设计**



### Java类及类的成员

现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的**细胞**构成的。同理，Java代码世界是由诸多个不同功能的**类**构成的。

现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… 那么，

Java中用类`class`来描述事物也是如此。常见的类的成员有：

- 属性：对应类中的成员变量 = `field` = 域、字段
- 行为：对应类中的成员方法 = 函数 = `method`

![image-20201208152801142](https://raw.githubusercontent.com/SaulJWu/images/main/20201208152801.png)



### 类的语法格式

~~~java
修饰符 class 类名{
    属性声明;
    方法声明;
}
~~~

修饰符`public`：**类可以被任意访问**。

**类的正文要用**{ }括起来，{}就是作用域。



### 创建Java自定义类

**步骤：**

1. 定义类（考虑修饰符、类名）

2. 编写类的属性（考虑修饰符、属性类型、属性名、初始化值）

3. 编写类的方法（考虑修饰符、返回值类型、方法名、形参等）



比如：

~~~java
package oopTest;

public class Person {
    int age;
    String name;
    int gender;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getGender() {
        return gender;
    }

    public void setGender(int gender) {
        this.gender = gender;
    }
}
~~~



### 类的创建和使用

**创建对象语法：** **类名 对象名** **= new** **类名();**

使用**对象名**.**对象成员**的方式访问对象成员（包括属性和方法）

~~~java
Person p = new Person();
p.name = "张三";
p.age = 18;
p.setGender(1);
int name1 = p.name;
int name2 = p.getName();
System.out.println(p.getAge())
~~~

创建对象，在有些地方也叫初始化或者实例化。

> 注意

如果创建了一个类的多个对象，每个对象都会在堆内存开辟新的空间，内存地址也是独立的，每个对象都独立的拥有一套类的属性。（非`static`）

意味着，如果去修改一个对象的属性a，则不影响另一个对象属性a的值。



如果把一个新的引用指向已经存在的对象，通过这个变量改变对象的值时，那么原来的变量访问对象的值时，会发现也改变了，因为2个引用都指向同一个对象的内存地址。

~~~java
Person p1 = new Person();
p1.setNmae("zhangsan");
p1.setAge(18);

Person p3 = p1;
p3.setAge(10);
Sysout.out.println(p1.age);//会返回10而不是18，因为2个引用指向一个对象，都是同一个内存地址。
~~~

> 什么是引用？

~~~java
int i;//创建一个引用
int j = 10;//创建一个引用并且把10赋值给这个引用
Person p1;//创建一个引用
Person p2 = new Person();//创建一个引用，并且在堆空间中实例一个对象，这个引用指向这个对象。
~~~

如果非要比喻的话：

引用，可以理解为遥控器。

对象，理解为电视机。

引用可以多个，那么遥控器可以多个，也可以独立存在，任意一个遥控器改变了电视频道，就像代码中，使用其中一个引用改变对象的值，那么第二个引用去访问对象时，发现对象的值已经改变了，因为2个引用都指向同一个对象的内存地址。

### 内存解析

![image-20201210190151104](C:\Users\SaulJ\AppData\Roaming\Typora\typora-user-images\image-20201210190151104.png)

- 堆（`Heap`），此内存区域的唯一目的就是==存放对象实例==，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。

- 通常所说的栈（`Stack`），是指==虚拟机栈==。虚拟机栈用于==存储局部变量==等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。==方法执行完，自动释放==。

- 方法区（`MethodArea`），用于==存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据==。

![image-20201210191318229](https://raw.githubusercontent.com/SaulJWu/images/main/20201210211013.png)





### 匿名对象

==*匿名对象*==就是没有明确的给出名字的对象。一般*匿名对象*只使用一次，而且==*匿名对象*==只在堆内存中开辟空间，而不存在栈内存的**引用**。

比如：

~~~java
new Person().eat();
new Person().sleep();
~~~

一般*匿名对象*只使用一次，但是有时也存在一些场景，把匿名对象的内存整数地址传递给另一个方法继续使用。

比如：

~~~java
House h = new House();
h.in(new Person())
    
public class House{
    public void in(Person person){
        System.out.println("他在这个屋子生活了"+person.age+"年");
    }
}
~~~



### 对象与数组

数组的语法格式还记得吗？

```
数据类型[] 变量名 = new 数据类型[长度]
```

其实数据类型不止是基本数据类型，对象也是一种数据类型，只不过不属于基本数据类型而已。

比如：

~~~java
Person[] personArr = new Person[10];
for(int i=0;i<personArr.length;i++){
    personArr[i] = new Person();//实例化
    personArr[i].setAge(18);
}
~~~

本质意义上其实和数组一样使用，而且如果复制数组不能直接赋值。具体可以回去数组章节中查看。

## 类的成员

### 属性`field`

类的成员有2个：

- 属性
- 方法

其中属性也可以叫**成员变量**或者**字段**，方法也可以叫函数。

在类内部声明的变量，称为==成员变量==。

在方法体内部声明的变量，称为==局部变量==。

> 属性的语法格式

修饰符 数据类型 属性名 =  初始化值;

- 修饰符
  - 常用的权限修饰符有：private、缺省、protected、public
  - 其他修饰符：static、final (暂不考虑)
- 数据类型
  - 任何基本数据类型(如int、Boolean) 或任何引用数据类型。
- 属性名
  - 属于标识符，符合命名规则和规范即可。





> 属性（成员变量）与局部变量的区别

|              | 成员变量                         | 局部变量                                 |
| ------------ | -------------------------------- | ---------------------------------------- |
| 声明的位置   | 直接在类中声明                   | 方法形参或内部、代码块内、构造器内等     |
| 修饰符       | private、public、static、final等 | 不能用权限修饰符修饰，可以用final修饰    |
| 初始化值     | 有默认初始化值                   | 没有默认初始化值，必须显式赋值，方可使用 |
| 内存加载位置 | 堆空间或静态域内                 | 栈空间                                   |

> 属性（成员变量）与局部变量的相同点

- 定义变量的格式：数据类型 变量明 = 变量值
- 先声明，后使用
- 变量都有其对应的作用域



> 成员变量的基本类型默认值

如果类的成员变量（字段）是基本数据类型，那么在类初始化（实例化）时，这些类型将会被赋予一个初始值。

| 基本类型 | 初始值        |
| -------- | ------------- |
| boolean  | false         |
| char     | \u0000 (null) |
| byte     | (byte) 0      |
| short    | (short) 0     |
| int      | 0             |
| long     | 0L            |
| float    | 0.0f          |
| double   | 0.0d          |

这些默认值仅在 Java 初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在 C++ 中不会），从而减少了 bug 的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。 所以，为了安全，我们最好始终显式地初始化变量。

这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。



### 方法`method`

> 什么是方法？

方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。

将功能封装为方法的目的是，可以实现代码重用，简化代码。

Java里的方法不能独立存在，所有的方法必须定义在类里。

> 方法的声明与使用

**语法格式**：

```
修饰符 返回值类型 方法名(形参列表){
	……
	return 返回值;
}
```

- 修饰符

  - public,缺省,private, protected
  - static、final (暂不考虑)

- 返回值类型：声明出返回值的类型。与方法体中“return 返回值”搭配使用

  - 可以是基本数据类型
  - 如果返回值类型是`void`，代表没有返回值，不需要用`return`
  - 也可以是==对象==

- 方法名：属于标识符，命名时遵循标识符命名规则和规范，“见名知意”

  形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开

  - 参数类型可以是基本数据类型，也可以是对象
  - 语法格式：数据类型 变量名1，数据类型 变量名2，数据类型 变量名3……
  - 形参属于局部变量。

- return：代表方法结束，作用是方法在执行完毕后返还给调用它的程序的数据。来返回指定类型的变量或常量。

  - 如果返回值类型是`void`，就不用使用`return`关键字;
  - 在同一个作用域(就是大括号的意思)，return后面不能有执行语句

- 返回值：可以是变量或者常量，配合`return`关键字一起用

  - 返回值的类型必须和返回值类型是一致的。

**例如：**

~~~java
public class Person{
    private String name;
    private int age;
    
    public int getAge(){
        return age;
    }
    
    public void setAge(int i){
        age = i;
    }
    
    public void eat(){
        System.out.println("吃饭");
    }
    
    public void sleep(int hour){
        System.out.println("睡了"+hour+"小时");
    }
}
~~~

> 如果按照是否有形参及返回值来对方法分类：

|        | 无返回值                  | 有返回值                         |
| ------ | ------------------------- | -------------------------------- |
| 无形参 | void 方法名（）{}         | 返回值的类型方法名（）{}         |
| 有形参 | void 方法名（形参列表）{} | 返回值的类型方法名（形参列表）{} |

> 方法的调用

方法通过方法名被调用，且只有被调用才会执行

**方法的调用过程分析：**

![image-20201210211004197](https://raw.githubusercontent.com/SaulJWu/images/main/20201210211004.png)

**注意：**

- 方法被调用一次，就会执行一次
- 没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。

- 定义方法时，方法的结果应该返回给调用者，交由调用者处理。
- 方法中只能调用方法或属性，不可以在方法内部定义方法。







## 方法的重载

> 重载的概念`overload`

在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可

> 重载的特点

与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。

> 重载实例

~~~java
//返回两个整数的和
int add(intx,inty){return x+y;}
//返回三个整数的和
intadd(intx,inty,intz){return x+y+z;}
//返回两个小数的和
double add(double x,doubley){return x+y;}
~~~

> 在通过对象调用方法时，如何确定某一个指定的方法

看好方法名和参数列表，重载的参数列表都是不相同的，所以只要找到对应的方法所需要的参数，就可以了。

其实我们用到最多的是重载是`System.out.println`

![image-20201210220527030](https://raw.githubusercontent.com/SaulJWu/images/main/20201210220527.png)

> 练习

~~~java
package overload;

/**
 * 编写程序，定义三个重载方法并调用。方法名为mOL。
 * 三个方法分别接收一个int参数、两个int参数、一个字符串参数。分别执行平方运算并输出结果，相乘并输出结果，输出字符串信息。
 * 在主类的main ()方法中分别用参数区别调用三个方法。
 */
public class Demo1 {

    public static void main(String[] args) {
        new Demo1().mOL(7);
        new Demo1().mOL(9, 9);
        new Demo1().mOL("test");
    }

    public void mOL(int num) {
        System.out.println(num * num);
    }

    public void mOL(int num1, int num2) {
        System.out.println(num1 * num2);
    }

    public void mOL(String str) {
        System.out.println(str);
    }
}
~~~

~~~java
package overload;

/**
 * 定义三个重载方法max()，
 * 第一个方法求两个int值中的最大值，
 * 第二个方法求两个double值中的最大值，
 * 第三个方法求三个double值中的最大值，
 * 并分别调用三个方法。
 */
public class Demo2 {

    public static void main(String[] args) {
        System.out.println(new Demo2().max(34, 46));
        System.out.println(new Demo2().max(3.4, 1.2));
        System.out.println(new Demo2().max(4.7, 45.3, 72.1));
    }

    public int max(int num1, int num2) {
        return num1 > num2 ? num1 : num2;
    }

    public double max(double d1, double d2) {
        return d1 > d2 ? d1 : d2;
    }

    public double max(double d1, double d2, double d3) {
        return d1 > d2 ? (d1 > d3 ? d1 : d3) : (d2 > d3 ? d2 : d3);
    }
}
~~~





## 可变形参的方法

JavaSE 5.0 中提供了`Varargs`(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。

```java
//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量
public static void test(int a ,String[] books);
```

```java
//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量
public static void test(int a ,String...books);
```

**说明：**

- 声明格式：==方法名(参数的类型名...参数名)==
- 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个
- 可变个数形参的方法与同名的方法之间，彼此构成重载
- 可变参数方法的使用与方法参数部分使用数组是一致的。二者不能共存，不能构成重载。
- 方法的参数部分有可变形参，需要放在形参声明的最后
- 在一个方法的形参位置，最多只能声明一个可变个数形参

**例如：**

~~~java
package com.sauljwu.mybatisdemo;

public class TestOverload {
    public void test(String[] msg) {
        System.out.println("含字符串数组参数的test方法");
    }

    public void test1(String book) {
        System.out.println("****与可变形参方法构成重载的test1方法****");
    }

    public void test1(String... books) {
        System.out.println("****形参长度可变的test1方法****");
        for(int i=0;i<books.length;i++){
            System.out.println(books[i]);
        }
    }

    public static void main(String[] args) {
        TestOverload to = new TestOverload();
        //下面两次调用将执行第二个test方法
        to.test1();to.test1("aa" , "bb");
        //下面将执行第一个test方法
        to.TestOverload(new String[]{"aa"});
    }
}
~~~



## 方法参数的值传递机制

方法，必须由其所在类或对象调用才有意义。若方法含有参数：

- 形参：方法声明时的参数
- 实参：方法调用时实际传给形参的参数值

> Java的实参值如何传入方法呢？

Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。

- 形参是==基本数据类型==：将实参基本数据类型变量的“`数据值`”传递给形参

- 形参是==引用数据类型==：将实参引用数据类型变量的“`地址值`”传递给形参

意思是，

> 基本数据类型的参数传递

~~~java
package method;

import switchTest.demo1;

public class Demo1 {
    public static void main(String[] args) {
        int x = 5;
        System.out.println("main方法中的x = " + x);
        Demo1 demo1 = new Demo1();
        demo1.change(x);
        System.out.println("main方法中的x = " + x);
    }

    public void change(int x){
        System.out.println("change方法中的x = " + x);
        x = 3;
        System.out.println("change方法中的x = " + x);
    }
}
~~~

```
main方法中的x = 5
change方法中的x = 5
change方法中的x = 3
main方法中的x = 5
```

![image-20201210223825718](https://raw.githubusercontent.com/SaulJWu/images/main/20201210223825.png)

**如果变量是基本数据类型，此时赋值是变量保存数据值，就算其他变量也赋值相同的数据，不会有影响，相互独立。**





> 引用数据类型的参数传递

~~~java
package method;

public class Demo2 {
    public static void main(String[] args) {
        Person person = new Person();
        person.age = 5;
        System.out.println("main方法中，未调用change，person.age = " + person.age);
        change(person);
        System.out.println("main方法中，已调用change，person.age = " + person.age);
    }
    public static void change(Person person){
        System.out.println("change方法中，改变之前，person.age = " + person.age);
        person.age = 3;
        System.out.println("change方法中，改变之之后，person.age = " + person.age);
    }

}


class Person{
    int age;
}
~~~

```
main方法中，未调用change，person.age = 5
change方法中，改变之前，person.age = 5
change方法中，改变之之后，person.age = 3
main方法中，已调用change，person.age = 3
```

**内存分析：**

![image-20201210224905019](https://raw.githubusercontent.com/SaulJWu/images/main/20201210224905.png)

**如果变量是引用数据类型，此时赋值是变量保存对象内存整数地址，当2个变量都指向同一个对象时，其中一个变量改变数据时，另一个变量访问时，也会发现已经改变了的值。**

还记得我前面提到的话吗？

如果把一个新的引用指向已经存在的对象，通过这个变量改变对象的值时，那么原来的变量访问对象的值时，会发现也改变了，因为2个引用都指向同一个对象的内存地址。

如果非要比喻的话：

引用（变量），可以理解为遥控器。

对象，理解为电视机。

引用可以多个，那么遥控器可以多个，也可以独立存在，任意一个遥控器改变了电视频道，就像代码中，使用其中一个引用改变对象的值，那么第二个引用去访问对象时，发现对象的值已经改变了，因为2个（变量）引用都指向同一个对象的内存地址。



### 面试题

![image-20201210230130261](https://raw.githubusercontent.com/SaulJWu/images/main/20201210230130.png)

> 方法一：调用完`method`方法退出系统

~~~java
package method;

public class Test {
    public static void main(String[] args) {
        int a= 10;
        int b= 10;
        method(a, b);
        System.out.println("a = " + a);
        System.out.println("b = " + b);
    }

    public static void method(int a, int b) {
        a *= 10;
        b *= 20;
        System.out.println("a = " + a);
        System.out.println("b = " + b);
        System.exit(0);
    }
}
~~~

> 方法2：重写`System.out.println`

~~~java
package method;

import java.io.PrintStream;

public class Test {
    public static void main(String[] args) {
        int a = 10;
        int b = 10;
        method(a, b);
        System.out.println("a = " + a);
        System.out.println("b = " + b);
    }

    public static void method(int a, int b) {
        PrintStream ps = new PrintStream(System.out) {
            @Override
            public void println(String x) {
                if ("a = 10".equals(x)) {
                    x = "a = 100";
                } else if ("b = 10".equals(x)) {
                    x = "b = 200";
                }
                super.println(x);
            }
        };
        System.setOut(ps);
    }
}
~~~

### 面试题2

![image-20201210231247481](https://raw.githubusercontent.com/SaulJWu/images/main/20201210231247.png)

### 面试题3

~~~java
int[] arr = new int[10];
System.out.println(arr);//地址值? 是地址值

char[] arr1 = new char[10];
System.out.println(arr1);//地址值? 不是
~~~

> int调用的方法如下：

~~~java
public void println(Object x) {
    String s = String.valueOf(x);
    synchronized (this) {
        print(s);
        newLine();
    }
}
~~~

因为传递的是引用数据类型，所以是相当于把地址值传递过去



> char调用的方法如下：

~~~java
public void println(char x[]) {
    synchronized (this) {
        print(x);
        newLine();
    }
}
~~~

因为传递的基本数据类型，所以打印的不是地址，直接拷贝一份数据，输出真实数据。

### 练习

1. 定义一个Circle类，包含一个double型的radius属性代表圆的半径，一个findArea()方法返回圆的面积。

2. 定义一个类PassObject，在类中定义一个方法printAreas()，该方法的定义如下：public void printAreas(Circle c,int time)在printAreas方法中打印输出1到time之间的每个整数半径值，以及对应的面积。例如，times为5，则输出半径1，2，3，4，5，以及对应的圆面积。
3. 在main方法中调用printAreas()方法，调用完毕后输出当前半径值。程序运行结果如图所示。

~~~java
package method;

public class Circle {

    double radius;

    public double findArea(){
        return Math.PI * radius * radius;
    }
}
~~~

~~~java
package method;

public class PassObject {

    public void printAreas(Circle c,int time){
        System.out.println("半径\t面积");
        for(int i=1;i<=time;i++){
            c.radius = i;
            System.out.println(i+"\t"+c.findArea());
        }
    }

    public static void main(String[] args) {
        PassObject passObject = new PassObject();
        passObject.printAreas(new Circle(), 5);
    }
}
~~~

```
半径	面积
1	3.141592653589793
2	12.566370614359172
3	28.274333882308138
4	50.26548245743669
5	78.53981633974483
```





## 递归方法 `recursion`

> 什么是递归？

递归方法：一个方法体内调用它自身。

方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。

递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。



> **计算1-100之间所有自然数之和：**

~~~java
package recursion;

public class Demo1 {

    public int recursion(int num){
        if(num == 1){
            return 1;
        }
        return num + recursion(num-1);
    }


    public static void main(String[] args) {
        //计算1-100之间所有自然数之和
        int recursion = new Demo1().recursion(100);
        System.out.println("recursion = " + recursion);

    }
}
~~~

```
recursion = 5050
```



> **请用Java写出递归求阶乘(n!)的算法**：

已经超出int范围了，如果是100，只能用`BigInteger`

~~~java
package recursion;

import java.math.BigInteger;

public class Demo2 {

    public BigInteger recursion(BigInteger num){
        if(num.compareTo(new BigInteger("1")) == 0){
            return new BigInteger("1");
        }
        return num.multiply(recursion(num.subtract(new BigInteger("1"))));
    }


    public static void main(String[] args) {
        //计算1-100之间所有自然数之积
        BigInteger recursion = new Demo2().recursion(new BigInteger("100"));
        System.out.println("recursion = " + recursion);
    }
}
~~~

```
recursion = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
```



> 已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),其中n是大于0的整数，求f(10)的值。

f(n+2)=2*f(n+1) + f(n) 

假设n等于0

f(0 + 2) = 2 * f(0 + 1) + f(0)

f(2) = 2*f(1)+f(0)

f(2) = 2 * 4 +1 = 9

求f(10) = f(8+2) = 2 * f(8+1) + f(8)

所以f(n)= 2*f(n-1)+f(n-2)

~~~java
package recursion;

public class Demo3 {

    public static void main(String[] args) {
        //已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),其中n是大于0的整数，求f(10)的值。
        int f = new Demo3().f(10);
        System.out.println("f = " + f);
    }

    public int f(int n) {
        if(n == 0){
            return 1;
        }else if(n == 1){
            return 4;
        }else{
            return  2 * f(n - 1) + f(n-2);
        }
    }
}
~~~

```
f = 10497
```

而且这个公式，当n=2时，也能计算出结果是9。



> 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值1  1  2  3  5  8  13  21  34  55
>
> 规律：一个数等于前两个数之和
>
> 要求：计算斐波那契数列(Fibonacci)的第n个值，并将整个数列打印出来

~~~java
package recursion;

/**
 * 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值 1  1  2  3  5  8  13  21  34  55
 * <p>
 * 规律：一个数等于前两个数之和
 * <p>
 * 要求：计算斐波那契数列(Fibonacci)的第n个值，并将整个数列打印出来
 */
public class Demo4 {
    public static void main(String[] args) {
        int n = 10;
        for (int i = 1; i <= 10; i++) {
            int fibonacci = new Demo4().fibonacci(i);
            System.out.print(fibonacci + "\t");
        }
    }

    public int fibonacci(int n) {
        if (n < 3) {
            return 1;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }
}
~~~

```
1	1	2	3	5	8	13	21	34	55	
```



> **汉诺塔**（港台：**河内塔**）是根据一个传说形成的数学问题：
>
> 有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：
>
> 1. 每次只能移动一个圆盘；
> 2. 大盘不能叠在小盘上面。
>
> 提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。
>
> 问：如何移？最少要移动多少次？

~~~java
package recursion;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * **汉诺塔**（港台：**河内塔**）是根据一个传说形成的数学问题：
 * <p>
 * 有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：
 * <p>
 * 1. 每次只能移动一个圆盘；
 * 2. 大盘不能叠在小盘上面。
 * <p>
 * 提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。
 * <p>
 * 问：如何移？最少要移动多少次？
 */
public class Demo5 {
    public static void main(String[] args) {
//        new Demo5().hanoi(3, 'A', 'B', 'C');
        List list = new ArrayList<>();
        list.add(15);
        list.add(10);
        list.add(5);
        new Demo5().init(list);
    }

    public void init(List a) {
        int n = a.size();
        List b = new ArrayList();
        List c = new ArrayList();
        test(n, a, b, c,new int[]{0});
    }



    public void test(int n, List a, List b, List c,int[] count) {
        if (n == 1) {
            count[0]++;
            System.out.println("--------第"+count[0]+"次-------");
            c.add(a.remove(a.size() - 1));
            System.out.println(a.toString());
            System.out.println(b.toString());
            System.out.println(c.toString());
            System.out.println("---------------------");
        }else{
            test(n - 1, a, c, b,count);
            test(1, a, b, c,count);
            test(n - 1, b, a, c,count);
        }
    }

    public void hanoi(int n, char a, char b, char c) {
        if (n == 1) {
            System.out.println(a + ">>" + c);
        } else {
            hanoi(n - 1, a, c, b);
            hanoi(1, a, b, c);
            hanoi(n - 1, b, a, c);
        }
    }
}
~~~

