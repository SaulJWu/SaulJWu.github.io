---
title: Object类
date: 2020-12-11 20:18:49
permalink: /pages/dc40f6/
categories:
  - 后端
  - Java
tags:
  - 
---
## Java Object 类

`Java Object` 类是所有类的父类，也就是说 `Java` 的所有类都继承了 `Object`，**子类可以使用 Object 的所有方法**。

如果在类的声明中未使用`extends`关键字指明其父类，则默认父类为`java.lang.Object`类，如果使用了`extends`关键字指明了父类，那么也算是间接继承`Object`。



> 如何证明？

~~~java
package ObjectDemo;

import com.sun.xml.internal.ws.wsdl.writer.document.Types;

public class ObjectTest {
    public static void main(String[] args) {
        Test test = new Test();
        System.out.println("Test的父类是：" + test.getClass().getSuperclass());
        TestB testB = new TestB();
        System.out.println("TestB的父类的父类是："+testB.getClass().getSuperclass().getSuperclass());
    }
}

class TestB extends Test{

}

class Test{

}
~~~

```
Test的父类是：class java.lang.Object
TestB的父类的父类是：class java.lang.Object
```



## 常用方法

| NO.  | 方法名称                            | 类型 | 描述                         |
| ---- | ----------------------------------- | ---- | ---------------------------- |
| 1    | `public Object()`                   | 构造 | 构造器                       |
| 2    | `public boolean equals(Object obj)` | 普通 | 对象比较                     |
| 3    | `public int hashCode()`             | 普通 | 取得`Hash`码                 |
| 4    | `public String toString()`          | 普通 | 转换为字符串，对象打印时调用 |



## finalize

> Called by the garbage collector on an object when garbage  collection determines that there are no more references to the object.

![image-20201211210139047](https://raw.githubusercontent.com/SaulJWu/images/main/20201211210139.png)

当GC垃圾回收器发现没有任何引用指向对象时，垃圾收集器就会调用当前的`finalize`方法。

> Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup.
> The general contract of finalize is that it is invoked if and when the Java™ virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded.
>
> The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition.
>
> The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates.
>
> After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded.
>
> The finalize method is never invoked more than once by a Java virtual machine for any given object.
>
> Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored

**google翻译:**

> 当垃圾回收确定不再有对该对象的引用时，由垃圾回收器在对象上调用。子类覆盖finalize方法以处置系统资源或执行其他清除。
> finalize的一般约定是，当Java™虚拟机确定不再有任何手段可以使尚未死亡的任何线程可以访问该对象时（除非是由于操作而导致），调用finalize。由完成的其他某些对象或类的完成确定。 finalize方法可以采取任何措施，包括使该对象可再次用于其他线程。但是，finalize的通常目的是在清除对象之前将其清除。例如，代表输入/输出连接的对象的finalize方法可能会执行显式I / O事务，以在永久丢弃该对象之前中断连接。
>
> Object类的finalize方法不执行任何特殊操作；它只是正常返回。 Object的子类可以覆盖此定义。
>
> Java编程语言不能保证哪个线程将为任何给定对象调用finalize方法。但是，可以保证，在调用finalize时，调用finalize的线程将不持有任何用户可见的同步锁。如果finalize方法抛出未捕获的异常，则该异常将被忽略，并且该对象的终结将终止。
>
> 在为对象调用finalize方法之后，直到Java虚拟机再次确定不再有任何方法可以由尚未死亡的任何线程访问该对象之后，才采取进一步的措施，包括可能的措施可以通过其他准备完成的对象或类来完成，此时可以丢弃该对象。
>
> 对于任何给定的对象，Java虚拟机都不会多次调用finalize方法。
>
> 由finalize方法引发的任何异常都将导致该对象的终止终止，但否则将被忽略。

垃圾回收机制关键点


垃圾回收机制只回收JVM堆内存里的对象空间。对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。


现在的JVM有多种垃圾回收实现算法，表现各异。


垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。


可以将对象的引用变量设置为`null`，暗示垃圾回收机制可以回收该对象。


程序员可以通过`System.gc()`或者`Runtime.getRuntime().gc()`来**通知**系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。（你家煤气坏了打电话通知物业来修，物业也不一定能来👿）


垃圾回收机制回收任何对象之前，总会先调用它的`finalize`方法（**如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象**）。


永远不要主动调用某个对象的`finalize`方法，应该交给垃圾回收机制调用。

> 有兴趣可以去买本书或者自己钻研JVM原理。
>
> 现在简单测试一下

~~~java
package JVMTest;

import java.lang.ref.PhantomReference;
import java.lang.ref.WeakReference;

public class JvmDemo {
    public static void main(String[] args) {
        Person person = new Person("Saul", 18);
        System.out.println(person);
        //指向空指针
        person = null;
        //强制回收
        System.gc();
    }

}

class Person {
    private String name;

    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    protected void finalize() throws Throwable {
        System.out.println("对象被释放：" + this);
    }


    @Override
    public String toString() {
        return "Person [name=" + this.name + ",age=" + this.age + "]";
    }
}
~~~

```
Person [name=Saul,age=18]
对象被释放：Person [name=Saul,age=18]
```

发现当我调用`System.gc()`强制回收之前，会自动调用`finalize`方法。



> 有一个面试题，`final`、`finally`、`finalize`这三个有什么区别？

前面2个是关键字 ，而`finalize`会垃圾回收机制回收任何对象之前，自动调用。





## `==`和`equals`

> `==`

- 基本类型比较值:只要两个变量的值相等，即为`true`。

- 引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，`==`才返回`true`
  - 用“`==`”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错。



> `equlas`

- 所有类都继承了Object，也就获得了equals()方法。还可以重写。
  - 只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。
  - 格式:`obj1.equals(obj2)`