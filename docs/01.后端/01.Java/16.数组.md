## 数组(Array)的概述

是多个**相同类型数据**按**一定顺序排列**的集合，并使用**一个名字命名**，并通过**编号**的方式对这些数据进行统一管理。



## 数组的常见概念

- 数组名
- 下标（或索引或角标）
- 元素
- 数组的长度



## 数组的特点

- 数组本身是**引用数据类型**，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。
- 创建数组对象在内存中开辟一整块**连续的空间**，而数组名中引用的是这块连续空间的首地址
- 数组的长度一旦确定，就不能修改。
- 数组是有序排列的。可以通过下标的方式指定位置的元素。

> 还有一种不是连续空间的，叫列表，后面会提到。

> 数组的长度不能修改，如果要增加元素只能重新开辟内存空间，把原来的元素拷贝进去，追加新元素。



## 数组的分类

按照维度：

一维数组、二维数组、三维数组……



按照元素的数据类型分类：

基本数据类型元素的数组、引用数据类型元素的数组（即对象数组）



## 一维数组

接下来我们将学习

1. 一维数组的声明和初始化
2. 如何调用数组的指定位置和元素
3. 如何获取数组的长度
4. 如何遍历数组
5. 数组元素的默认初始化值
6. 数组的内存解析



### 声明和初始化

#### 语法格式

~~~java
数据类型[] 变量名;
变量名 = new 数据类型[]{...}
~~~

~~~java
数据类型[] 变量名 = new 数据类型[]{...}
~~~

```java
数据类型 变量名[] = new 数据类型[]{...}
```

```java
数据类型[] 变量名 = {...}
```

还有一种直接将引用指向某个引用



#### 静态初始化

数组的初始化和数组的元素的赋值操作同时进行，称为数组的静态初始化。

声明：

~~~java
int[] ids;
~~~

初始化：

~~~java
ids = new int[]{123,124,125}
~~~

> 数组是引用数据类型，一定要用new

当然也可以声明和初始化一起写：

~~~java
int[] ids = new int[]{123,124,125}
~~~



#### 动态初始化

数组的初始化和数组的元素的赋值操作分开进行，称为数组的动态初始化。

~~~java
String[] names = new String[5]
~~~

> 在实际业务场景中，有时候我们不能确定元素的赋值，所以需要先声明后面逻辑操作获得赋值。



#### 错误的写法

~~~java
int[] arr1 = new int[];
int[5] arr2 = new int[5];
int[] arr3 = new int[3]{1,2,3};
~~~



### 调用数组

如何调用数组的指定位置和元素?通过下标（索引或角标）的方式调用。

数组的下标（或索引） 是从0开始的，到数组的长度-1结束。

例如：

~~~java
String[] names = new String[5]
names[0] = "名字一";
names[1] = "名字二";
names[2] = "名字三";
names[3] = "名字四";
names[4] = "名字五";
~~~



当你尝试操作第6个下标，会发生数组越界

~~~java
names[5] = "名字六";
~~~

编译虽然能通过，但是程序会报`java.lang.ArrayIndexOutOfBoundsException`

因为在初始化时，数组的长度只有5，当你去访问第6个，自然会数组越界。



### 数组长度

每个数组都有个`length`属性，例如上面案例中，可以这样访问：

~~~java
System.out.println(names.length)
~~~

将会返回5。



### 遍历数组

还是用上面`names`数组：

~~~java
for(int i=0;i<names.length-1;i++){
    System.out.println(names[i]);
}
~~~



### 默认初始化值

如果数组初始化时，元素不指定值，会根据数组类型产生默认值。

- 整型，默认值为：0
- 浮点型，默认值为：0.0
- char型，默认值为：0或‘\u0000’，而非‘0’
- boolean型，默认值为：false
- 如果元素是引用数据类型，默认值为：null



数组元素是`int`类型

~~~java
package arrayTest;

public class Demo1 {
    public static void main(String[] args) {
        int[] arr = new int[4];
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
~~~

```
0
0
0
0
```

数组元素是`short`类型

~~~java
short[] arr2 = new short[4];
for (int i = 0; i < arr2.length; i++) {
    System.out.println(arr2[i]);
}
~~~

```
0
0
0
0
```

数组元素是`float`类型

```java
float[] arr3 = new float[4];
for (int i = 0; i < arr3.length; i++) {
System.out.println(arr3[i]);
}
```

```
0.0
0.0
0.0
0.0
```

数组元素是`char`类型

~~~java
char[] arr4 = new char[4];
for (int i = 0; i < arr4.length; i++) {
    System.out.println("---" + arr4[i] + "***");
    if(arr4[i] == 0){
        System.out.println("默认是0或‘\\u0000’，而非‘0’");
    }
}
~~~

```
--- ***
默认是0或‘\u0000’，而非‘0’
--- ***
默认是0或‘\u0000’，而非‘0’
--- ***
默认是0或‘\u0000’，而非‘0’
--- ***
默认是0或‘\u0000’，而非‘0’
```

数组元素是boolean类型

```java
boolean[] arr5 = new boolean[4];
for (int i = 0; i < arr5.length; i++) {
System.out.println(arr5[i]);
}
```

```
false
false
false
false
```

数组元素是引用数据类型

~~~java
String[] arr6 = new String[4];
for (int i = 0; i < arr6.length; i++) {
    System.out.println(arr6[i]);
    if (arr6[i] == null) {
        System.out.println("引用数据类型，默认值为：null");
    }
}
~~~

```
null
引用数据类型，默认值为：null
null
引用数据类型，默认值为：null
null
引用数据类型，默认值为：null
null
引用数据类型，默认值为：null
```



### 数组的内存解析

其实new关键字，就是面向对象的用法。



- 内存的结构

内存的规范首次是JVM的书籍中提到，不同JDK中当中，内存的结构稍微有所区别。

#### 简化图

内存中结构中，可以将内存划分为：

- 栈（stack）：局部变量

- 堆（heap）：new出来的结构：对象、数组

- 方法区（method area）
  - 常量池
  - 静态域

![image-20201207120317580](https://raw.githubusercontent.com/SaulJWu/images/main/20201207120317.png)





代码解析：

~~~java
int[] arr = new int[]{1,2,3};
~~~

![image-20201207123500421](https://raw.githubusercontent.com/SaulJWu/images/main/20201207123500.png)



### 练习1

公寓合租招租4个月，1550元/月（水电煤公摊，网费35元/月），由于屋内均是IT人士，所以他的联系方式为：

```
8,2,1,0,3
2,0,3,2,4,0,1,3,2,2,3
```

那么他的联系方式是？

~~~java
package arrayTest;

public class Demo2 {
    public static void main(String[] args) {
        int[] arr = new int[]{8, 2, 1, 0, 3};
        int[] index = new int[]{2, 0, 3, 2, 4, 0, 1, 3, 2, 2, 3};
        String tel = "";
        for (int i = 0; i < index.length; i++) {
            tel += arr[index[i]];
        }
        System.out.println("联系方式为：" + tel);
    }
}
~~~

```
联系方式为：18013820110
```



### 练习2

![image-20201207125849299](https://raw.githubusercontent.com/SaulJWu/images/main/20201207125849.png)

~~~java
package arrayTest;

import java.util.Scanner;

public class Demo3 {
    public static void main(String[] args) {
        int max = 0;
        Scanner scan = new Scanner(System.in);
        // 获取学生人数
        System.out.println("请输入学生的人数：");
        int nums = scan.nextInt();
        int[] scores = new int[nums];
        //获取学生分数
        System.out.println("请以此输入" + nums + "个学生的成绩：");
        for (int i = 0; i < scores.length; i++) {
            //给数组中的元素赋值
            scores[i] = scan.nextInt();
            if (max < scores[i]) {
                //获取最高分
                max = scores[i];
            }
        }
        //遍历数组，评级
        for (int i = 0; i < scores.length; i++) {
            String rate = "";
            if (scores[i] >= max - 10) {
                rate = "A";
            } else if (scores[i] >= max - 20) {
                rate = "B";
            } else if (scores[i] >= max - 30) {
                rate = "C";
            } else {
                rate = "D";
            }
            System.out.println("学号：" + i + "的学生成绩为：" + scores[i] + "，评级为：" + rate);
        }
    }
}
~~~



## 多维数组

Java语言里提供了支持多维数组的语法。多维数组又以二维数组居多。如果说可以把一堆数组当成几何中的线性图形，那么二维数组就相当于一个表格。对于二维数组的理解，我们可以看成一维数组又作为另一对堆一维数组的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。

接下来我们将学习

1. 二维数组的声明和初始化
2. 如何调用数组的指定位置和元素
3. 如何获取数组的长度
4. 如何遍历数组
5. 数组元素的默认初始化值
6. 数组的内存解析



### 声明和初始化

#### 语法格式

~~~java
数据类型[][] 变量名 = new 数据类型[][]{{……},{……},{……}}
~~~

```java
数据类型[] 变量名[] = new 数据类型[][]{{……},{……},{……}}
```

```java
数据类型 变量名[][] = new 数据类型[][]{{……},{……},{……}}
```

```java
数据类型[][] 变量名 = {{……},{……},{……}}
```



#### 静态初始化

~~~java
//一维数组
int[] arr = new int[]{1,2,3};
//二维数组
int[][] arr2 = new int[][]{{1,2,3},{4,5},{7,8,9}};
~~~



#### 动态初始化

~~~java
String[][] arr3 = new String[3][2];
String[][] arr4 = new String[3][];
~~~



#### 错误的写法

~~~java
String[][] arr5 = new String[][];
String[][] arr6 = new String[][3];
String[][] arr7 = new String[4][3]{{1,2,3},{4,5},{7,8,9}};
~~~



### 调用数组

~~~java
//二维数组
int[][] arr = new int[][]{{1,2,3},{4,5},{7,8,9}};
//访问外层元素
System.out.println(arr[0]);
//访问内层元素
System.out.println(arr[0][1]); //2
~~~

同样如果数组下标越界，也会报`java.lang.ArrayIndexOutOfBoundsException`



### 数组长度

~~~java
//二维数组
int[][] arr = new int[][]{{1,2,3},{4,5},{7,8,9}};
//外层元素长度
System.out.println(arr.length);//3
//内层元素长度
System.out.println(arr[1].length);//2
~~~



### 遍历数组

关于多维数组的遍历，二维就二层循环，n层就n层循环。

~~~java
package arrayTest;

public class Demo1 {
    public static void main(String[] args) {
        int[][] arr = new int[][]{{1,2,3},{4,5},{7,8,9}};
        for (int i = 0; i < arr.length; i++) {
            for(int j=0;j<arr[i].length;j++){
                System.out.print(arr[i][j]);
            }
            System.out.println();
        }
    }
}
~~~



### 默认初始化值

二维数组分为外层元素和内层元素。

外层元素是一个对象，内层元素是才是具体值。

~~~java
int[][] arr = new int[4][3];
System.out.println(int[0]);//内存地址
System.out.println(int[0][0])//0 一个整形
~~~

外层元素是指向一个对象的内层地址，代表一个对象。

内层元素是指向具体值。具体值的默认值跟一维数组的一样。



~~~java
int[][] arr = new int[4][];
~~~

外层元素是指向一个对象的内层地址，但是并没有指向任何对象，所以是null。

内层元素还没被创建，所以也不能访问。





### 内存解析

二维数组的内存解析

![image-20201207151525844](https://raw.githubusercontent.com/SaulJWu/images/main/20201207151526.png)



![image-20201207152116844](https://raw.githubusercontent.com/SaulJWu/images/main/20201207152117.png)



### 练习1

![image-20201207152216786](https://raw.githubusercontent.com/SaulJWu/images/main/20201207152216.png)

通过图像可知，存在一个多维数组

~~~java
package arrayTest;

import java.util.Scanner;

public class Demo4 {
    public static void main(String[] args) {
        int total = 0;
        int[][] arr = new int[][]{{3, 5, 8}, {12, 9}, {7, 0, 6, 4}};
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                total += arr[i][j];
            }
        }
        System.out.println(total);
    }
}
~~~

结果是54



### 练习2

![image-20201207152620975](https://raw.githubusercontent.com/SaulJWu/images/main/20201207152621.png)

a no，

b yes，

c no

d no

e yes

f no



### 练习3

![image-20201207152827198](https://raw.githubusercontent.com/SaulJWu/images/main/20201207152827.png)

```java
package arrayTest;

public class Demo5 {
    public static void main(String[] args) {
        int[][] arr = new int[10][];
        for (int i = 0; i < arr.length; i++) {
            System.out.print("[" + i + "] ");
            arr[i] = new int[i+1];
            for (int j = 0; j < arr[i].length; j++) {
                if (j == 0 || j == arr[i].length - 1) {
                    arr[i][j] = 1;
                } else if (i > 1) {
                    arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
                }

                System.out.print(arr[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

```
[0] 1 
[1] 1 1 
[2] 1 2 1 
[3] 1 3 3 1 
[4] 1 4 6 4 1 
[5] 1 5 10 10 5 1 
[6] 1 6 15 20 15 6 1 
[7] 1 7 21 35 35 21 7 1 
[8] 1 8 28 56 70 56 28 8 1 
[9] 1 9 36 84 126 126 84 36 9 1 
```



拓展题：

~~~java
package arrayTest;

public class Demo6 {
    public static void main(String[] args) {
        int[] arr = new int[6];
        int count = 0;
        for (int i = 0; i < arr.length; i++) {
            while (true) {
                boolean flag = true;
                int number = (int) (Math.random() * 30 + 1);
                System.out.print("\t随机值：" + number);
                for (int j = 0; j < count; j++) {
                    if (arr[j] == number) {
                        System.out.print("\t已存在！将重新生成!");
                        flag = false;
                    }
                }
                if(flag){
                    System.out.println("\t插入成功");
                    arr[i] = number;
                    count++;
                    break;
                }
            }
        }
        System.out.print("最后生成的值如下：");
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}
~~~



## 数组中的常见算法

数组中设计的常见算法：

1. 数组元素的赋值（杨辉三角、回型数等）
2. 求数值型数组中元素的最大值、最小值、平均数、总和等。
3. 数组的复制、反转、查找（线性查找、二分法查找等）
4. 数组元素的排序算法



### 回型算法

输入一个数字n，生成回型数字n，数字是n列，n行。并打印。

例如输入3

| 1    | 2    | 3    |
| ---- | ---- | ---- |
| 8    | 9    | 4    |
| 7    | 6    | 5    |

例如输入5

| 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- |
| 16   | 17   | 18   | 19   | 6    |
| 15   | 24   | 25   | 20   | 7    |
| 14   | 23   | 22   | 21   | 8    |
| 13   | 12   | 11   | 10   | 9    |

分析：

- 最大值为输入值的平方。
- 存在4条线

![image-20201207195704120](https://raw.githubusercontent.com/SaulJWu/images/main/20201207202747.png)

- 走完4个方向为一圈

假设输入5

第一圈

| 方向 | 步数 | 这条线多少个数字 | 见到倒数第n个截止 | 生成值      |
| ---- | ---- | ---------------- | ----------------- | ----------- |
| 向右 | 4    | 5                | 1                 | 1 2 3 4     |
| 向下 | 4    | 5                | 1                 | 5 6 7 8     |
| 向左 | 4    | 5                | 1                 | 9 10 11 12  |
| 向上 | 4    | 5                | 1                 | 13 14 15 16 |

第二圈
| 方向 | 步数 | 这条线多少个数字 | 见到倒数第n个截止 | 生成值 |
| ---- | ---- | ---------------- | ----------------- | ------ |
| 向右 | 2    | 5                | 2                 | 17 18  |
| 向下 | 2    | 5                | 2                 | 19 20  |
| 向左 | 2    | 5                | 2                 | 21 22  |
| 向上 | 2    | 5                | 2                 | 23 24  |

~~~java
package arrayTest;

import java.util.Scanner;

/**
 * 输入一个数字n，生成回型数字n，数字是n列，n行。并打印。
 */
public class Demo7 {
    public static void main(String[] args) {
        //获取输入的数字
        //初始化化二维数组
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个数字，将会自动成回形数：");
        if (!scan.hasNextInt()) {
            System.out.println("您输入的不是数字！");
        }
        int input = scan.nextInt();
        if (input <= 0) {
            System.out.println("请输入正整数！");
            return;
        }
        int[][] arr = new int[input][input];
        //控制赋值数字
        int count = 0;
        for (int i = 0; i < input * input; i++) {
            //向右，y轴不变，x轴自增，最多写入倒数第二个
            for (int y = i, x = i; x < input - i - 1; x++) {
                count++;
                arr[y][x] = count;
            }
            //向下，x轴不变，y轴自增，最多写入倒数第二个
            for (int y = i, x = input - i - 1; y < input - i - 1; y++) {
                count++;
                arr[y][x] = count;
            }
            //向左，y轴不变，x轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = input - i - 1; x > i; x--) {
                count++;
                arr[y][x] = count;

            }
            //向上，x轴不变，y轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = i; y > i; y--) {
                count++;
                arr[y][x] = count;
            }
        }
        //输出
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.println();
        }

    }
}
~~~

输入5：

```
1	2	3	4	5	
16	17	18	19	6	
15	24	0	20	7	
14	23	22	21	8	
13	12	11	10	9	
```

输入6：

```
1	2	3	4	5	6	
20	21	22	23	24	7	
19	32	33	34	25	8	
18	31	36	35	26	9	
17	30	29	28	27	10	
16	15	14	13	12	11
```

输入3：

```
1	2	3	
8	0	4	
7	6	5
```

发现了一个bug，当数字为奇数的时候，为0，那么很简单，只需要计算出来单独设置就可以了。

~~~java
//当为奇数时，需要单独设置中心点数字
if (input % 2 != 0) {
    arr[input / 2][input / 2] = input * input;
}
~~~

完整代码如下：

~~~java
package arrayTest;

import java.util.Scanner;

/**
 * 输入一个数字n，生成回型数字n，数字是n列，n行。并打印。
 */
public class Demo7 {
    public static void main(String[] args) {
        //获取输入的数字
        //初始化化二维数组
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个数字，将会自动成回形数：");
        if (!scan.hasNextInt()) {
            System.out.println("您输入的不是数字！");
        }
        int input = scan.nextInt();
        if (input <= 0) {
            System.out.println("请输入正整数！");
            return;
        }
        int[][] arr = new int[input][input];
        //当为奇数时，需要单独设置中心点数字
        if (input % 2 != 0) {
            arr[input / 2][input / 2] = input * input;
        }
        //控制赋值数字
        int count = 0;
        for (int i = 0; i < input * input; i++) {
            //向右，y轴不变，x轴自增，最多写入倒数第二个
            for (int y = i, x = i; x < input - i - 1; x++) {
                count++;
                arr[y][x] = count;
            }
            //向下，x轴不变，y轴自增，最多写入倒数第二个
            for (int y = i, x = input - i - 1; y < input - i - 1; y++) {
                count++;
                arr[y][x] = count;
            }
            //向左，y轴不变，x轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = input - i - 1; x > i; x--) {
                count++;
                arr[y][x] = count;

            }
            //向上，x轴不变，y轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = i; y > i; y--) {
                count++;
                arr[y][x] = count;
            }
        }
        //输出
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.println();
        }

    }
}
~~~



似乎还有另一种走法：

![image-20201207195752590](https://raw.githubusercontent.com/SaulJWu/images/main/20201207202747.png)



~~~java
package arrayTest;

import java.util.Scanner;

/**
 * 输入一个数字n，生成回型数字n，数字是n列，n行。并打印。
 */
public class Demo8 {
    public static void main(String[] args) {
        //获取输入的数字
        //初始化化二维数组
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个数字，将会自动成回形数：");
        if (!scan.hasNextInt()) {
            System.out.println("您输入的不是数字！");
        }
        int input = scan.nextInt();
        if (input <= 0) {
            System.out.println("请输入正整数！");
            return;
        }
        int[][] arr = new int[input][input];
        //控制赋值数字
        int count = 0;
        for (int i = 0; i < input * input; i++) {
            //向右，y轴不变，x轴自增
            for (int y = i, x = i; x < input - i; x++) {
                count++;
                arr[y][x] = count;
            }
            //向下，x轴不变，y轴自增
            for (int y = i + 1, x = input - i - 1; y < input - i; y++) {
                count++;
                arr[y][x] = count;
            }
            //向左，y轴不变，x轴自减
            for (int y = input - i - 1, x = input - i - 2; x >= i; x--) {
                count++;
                arr[y][x] = count;

            }
            //向上，x轴不变，y轴自减
            for (int y = input - i - 2, x = i; y > i; y--) {
                count++;
                arr[y][x] = count;
            }
        }
        //输出
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.println();
        }
    }
}
~~~



至此，已经实现了回型算法！



### 数值型相关练习

求数值型数组中元素的最大值、最小值、平均数、总和等。

定义一个int型的一维数组，包含10个元素，分别赋随机整数，然后求出所有元素的最大值，最小值，和值，平均值，并输出在控制台。

要求：所有随机数都是两位数。

实现代码：

~~~java
package arrayTest;

/**
 * 求数值型数组中元素的最大值、最小值、平均数、总和等。
 * <p>
 * 定义一个int型的一维数组，包含10个元素，分别赋随机整数，然后求出所有元素的最大值，最小值，和值，平均值，并输出在控制台。
 * <p>
 * 要求：所有随机数都是两位数。
 */
public class Demo9 {
    public static void main(String[] args) {
        int[] arr = new int[10];
        //最大值
        int max = 0;
        //最小值
        int min = 100;
        //和值
        int total = 0;

        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 90 + 10);
            System.out.print(arr[i] + "\t");
            //最大值
            if (max < arr[i]) {
                max = arr[i];
            }
            //最小值
            if (min > arr[i]) {
                min = arr[i];
            }
            //和值
            total += arr[i];

        }
        System.out.println();
        //平均值
        double avg = (double) total / arr.length;
        System.out.println("最大值为：" + max);
        System.out.println("最小值为：" + min);
        System.out.println("和值为：" + total);
        System.out.println("平均值为" + avg);
    }
}
~~~



### 数组的复制

使用简单数组

1. 创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。
2. 使用大括号{}，把array1初始化8个素数：2，3，5，7，11，13，17，19.
3. 显示array1的内容。
4. 赋值array2变量等于array1，修改array2中的偶索引元素，时期等于索引值（如array[0]=0,array[2]=2）。打印出array1。

思考：array1和array2是什么关系？

拓展：修改题目，实现array2对array1数组的复制。

~~~java
package arrayTest;

/**
 * 使用简单数组
 * <p>
 * 1. 创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。
 * 2. 使用大括号{}，把array1初始化8个素数：2，3，5，7，11，13，17，19.
 * 3. 显示array1的内容。
 * 4. 赋值array2变量等于array1，修改array2中的偶索引元素，时期等于索引值（如array[0]=0,array[2]=2）。打印出array1。
 * <p>
 * 思考：array1和array2是什么关系？
 * <p>
 * 拓展：修改题目，实现array2对array1数组的复制。
 */
public class ArrayTest {
    public static void main(String[] args) {
        int[] array1, array2;
        array1 = new int[]{2, 3, 5, 7, 11, 13, 17, 19};
        for (int i = 0; i < array1.length; i++) {
            System.out.print(array1[i] + "\t");
        }
        array2 = array1;
        for (int i = 0; i < array2.length; i++) {
            if (i % 2 == 0) {
                array2[i] = i;
            }
        }
        System.out.println();
        for (int i = 0; i < array1.length; i++) {
            System.out.print(array1[i] + "\t");
        }
    }
}
~~~

结果：

```
2	3	5	7	11	13	17	19	
0	3	2	7	4	13	6	19
```

> 思考：array1和array2是什么关系？

array1和array2地址值相同，都指向了堆空间的唯一的一个数组实体。所以修改array2时，实际上是修改内存中的实际值，当修改完毕后，array1也是指向这个内存，所以它打印的值也显示更改了。

![image-20201208095940116](https://raw.githubusercontent.com/SaulJWu/images/main/20201208095940.png)

> 赋值array2变量等于array1

数组不能这样赋值，如果要复制一份，需要重新在内存中开辟新的空间，重新新建数组实体。

~~~java
array2 = new int[array1.length];
for (int i = 0; i < array1.length; i++) {
    array2[i] = array1[i];
}
~~~

完整代码：

~~~java
package arrayTest;

/**
 * 使用简单数组
 * <p>
 * 1. 创建一个名为ArrayTest的类，在main()方法中声明array1和array2两个变量，他们是int[]类型的数组。
 * 2. 使用大括号{}，把array1初始化8个素数：2，3，5，7，11，13，17，19.
 * 3. 显示array1的内容。
 * 4. 赋值array2变量等于array1，修改array2中的偶索引元素，时期等于索引值（如array[0]=0,array[2]=2）。打印出array1。
 * <p>
 * 思考：array1和array2是什么关系？
 * <p>
 * 拓展：修改题目，实现array2对array1数组的复制。
 */
public class ArrayTest {
    public static void main(String[] args) {
        int[] array1, array2;
        array1 = new int[]{2, 3, 5, 7, 11, 13, 17, 19};
        for (int i = 0; i < array1.length; i++) {
            System.out.print(array1[i] + "\t");
        }
        /**
         * array1和array2地址值相同，都指向了堆空间的唯一的一个数组实体。
         * 所以修改array2时，实际上是修改内存中的实际值，
         * 当修改完毕后，array1也是指向这个内存，所以它打印的值也显示更改了。
         */
//        array2 = array1;
        //复制数组
        array2 = new int[array1.length];
        for (int i = 0; i < array1.length; i++) {
            array2[i] = array1[i];
        }
        //修改array2中的偶索引元素，时期等于索引值（如array[0]=0,array[2]=2）
        for (int i = 0; i < array2.length; i++) {
            if (i % 2 == 0) {
                array2[i] = i;
            }
        }
        System.out.println();
        for (int i = 0; i < array1.length; i++) {
            System.out.print(array1[i] + "\t");
        }
    }
}
~~~

输出结果：

```
2	3	5	7	11	13	17	19	
2	3	5	7	11	13	17	19	
```



### 数组的反转操作

方式一：

~~~java
package arrayTest;

public class Demo10 {
    public static void main(String[] args) {
        String[] arr = new String[]{"JJ", "DD", "MM", "BB", "GG", "AA"};
        //数组的反转
        for (int i = 0; i < arr.length / 2; i++) {
            String temp = arr[i];
            arr[i] = arr[arr.length - i - 1];
            arr[arr.length - i - 1] = temp;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "\t");
        }
    }
}
~~~

方式二：

~~~java
//方式二：
for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
    String temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
~~~







## 排序算法

> 前面用二分法的前提是有序，接下来我们了解一下排序的相关知识。

### 概念

排序：假设含有n个记录的序列为{R1,R2,…,Rn}，其相应的关键字序列为{K1,K2,…,Kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin}，使得相应的关键字值满足Ki1<=Ki2<=…<=Kin，这样的一种操作称为排序。

通常来说，排序的目的是快速查找。



### 优劣判断

衡量排序算法的优劣：（高效率、低存储）

1. 时间复杂度：分析关键字的比较次数和记录的移动次数。
2. 空间复杂度：分析排序算法中需要多少辅助内存。
3. 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。



### 分类

拍讯算法分类：内部排序和外部排序。

- 内部排序：整个排序的过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
- 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。



### 十大内部排序算法

- 选择排序
  - 直接选择拍讯、堆拍讯
- 交换排序
  - 冒泡排序、快速排序
- 插入排序
  - 直接插入排序、折半插入排序、Shell排序
- 归并排序
- 桶试排序
- 基数排序

> 冒泡排序和快速排序必须要会手写，堆排序和归并排序要能讲出来的，能够手写当然是最好的。



### 算法的5大特征

| 输入（Input）                   | 有0个或多个输入数据，这些输入必须有清楚的描述和定义          |
| ------------------------------- | ------------------------------------------------------------ |
| 输出（Output）                  | 至少有1个或多个输出结果，不可以没有输出结果                  |
| 有穷性（有限性，Finitenness）   | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 |
| 确定性（明确性，Definiteness）  | 算法中的每一步都有确定的含义，不会出现二义性                 |
| 可行性（有效性，Effectiveness） | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案   |

说明：满足确定性的算法也称为：确定性算法。现在人民也关注更广发的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程（procedure）。



## 线性查找

查找也可以称为搜索，所谓线性查找，就是直接遍历，找到一个符合条件的结果。

~~~java
package arrayTest;

public class Demo11 {
    public static void main(String[] args) {
        String[] arr = new String[]{"JJ", "DD", "MM", "BB", "GG", "AA"};
        String dest = "BB";
        boolean isFlag = true;
        for (int i = 0; i < arr.length; i++) {
            if (dest.equals(arr[i])) {
                System.out.println("找到了指定的元素，位置为" + i);
                isFlag = false;
                break;
            }
        }
        if (isFlag) {
            System.out.println("很遗憾，没有找到！");
        }
    }
}
~~~

```
找到了指定的元素，位置为3
```



## 二分法查找

二分法查找也叫折半查找，

（1）确定该区间的中间位置K

（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。

![image-20201208110127248](https://raw.githubusercontent.com/SaulJWu/images/main/20201208110127.png)

前提：所要查找的数组必须有序。

二分法查找特点是效率高。

~~~java
package arrayTest;

public class Demo12 {
    public static void main(String[] args) {
        int[] arr = new int[]{-98, -34, 2, 34, 54, 66, 79, 105, 210, 333};
        int dest = 35;
        //初始的首索引
        int head = 0;
        //初始的末尾索引
        int end = arr.length - 1;
        boolean isFlag = true;
        while (head <= end) {
            int middle = (head + end) / 2;
            if (dest == arr[middle]) {
                System.out.println("找到了，索引位置为：" + middle);
                isFlag = false;
                break;
            } else if (arr[middle] > dest) {
                end = middle - 1;
            } else {
                head = middle + 1;
            }
        }
        if(isFlag){
            System.out.println("很遗憾，没有找到！");
        }
    }
}
~~~

