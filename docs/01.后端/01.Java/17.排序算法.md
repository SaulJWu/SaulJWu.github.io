## 前言

前面学习了数组，数组中涉及的常见算法：

> 1. 数组元素的赋值（杨辉三角、回型数等）
> 2. 求数值型数组中元素的最大值、最小值、平均数、总和等。
> 3. 数组的复制、反转、查找（线性查找、二分法查找等）
> 4. 数组元素的排序算法
>





## 排序算法

> 前面用二分法的前提是有序，接下来我们了解一下排序的相关知识。

### 概念

排序：假设含有n个记录的序列为{R1,R2,…,Rn}，其相应的关键字序列为{K1,K2,…,Kn}。将这些记录重新排序为{Ri1,Ri2,…,Rin}，使得相应的关键字值满足Ki1<=Ki2<=…<=Kin，这样的一种操作称为排序。

通常来说，排序的目的是快速查找。



### 优劣判断

衡量排序算法的优劣：（高效率、低存储）

1. 时间复杂度：分析关键字的比较次数和记录的移动次数。
2. 空间复杂度：分析排序算法中需要多少辅助内存。
3. 稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。



### 分类

拍讯算法分类：内部排序和外部排序。

- 内部排序：整个排序的过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
- 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。



### 十大内部排序算法

- 选择排序
  - 直接选择拍讯、堆拍讯
- 交换排序
  - 冒泡排序、快速排序
- 插入排序
  - 直接插入排序、折半插入排序、Shell排序
- 归并排序
- 桶试排序
- 基数排序

> 冒泡排序和快速排序必须要会手写，堆排序和归并排序要能讲出来的，能够手写当然是最好的。



### 算法的5大特征

| 输入（Input）                   | 有0个或多个输入数据，这些输入必须有清楚的描述和定义          |
| ------------------------------- | ------------------------------------------------------------ |
| 输出（Output）                  | 至少有1个或多个输出结果，不可以没有输出结果                  |
| 有穷性（有限性，Finitenness）   | 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 |
| 确定性（明确性，Definiteness）  | 算法中的每一步都有确定的含义，不会出现二义性                 |
| 可行性（有效性，Effectiveness） | 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案   |

说明：满足确定性的算法也称为：确定性算法。现在人民也关注更广发的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程（procedure）。



## 线性查找

查找也可以称为搜索，所谓线性查找，就是直接遍历，找到一个符合条件的结果。

~~~java
package arrayTest;

public class Demo11 {
    public static void main(String[] args) {
        String[] arr = new String[]{"JJ", "DD", "MM", "BB", "GG", "AA"};
        String dest = "BB";
        boolean isFlag = true;
        for (int i = 0; i < arr.length; i++) {
            if (dest.equals(arr[i])) {
                System.out.println("找到了指定的元素，位置为" + i);
                isFlag = false;
                break;
            }
        }
        if (isFlag) {
            System.out.println("很遗憾，没有找到！");
        }
    }
}
~~~

```
找到了指定的元素，位置为3
```



## 二分法查找

二分法查找也叫折半查找，

（1）确定该区间的中间位置K

（2）将查找的值T与array[k]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。

![image-20201208110127248](https://raw.githubusercontent.com/SaulJWu/images/main/20201208110127.png)

前提：所要查找的数组必须有序。

二分法查找特点是效率高。

~~~java
package arrayTest;

public class Demo12 {
    public static void main(String[] args) {
        int[] arr = new int[]{-98, -34, 2, 34, 54, 66, 79, 105, 210, 333};
        int dest = 35;
        //初始的首索引
        int head = 0;
        //初始的末尾索引
        int end = arr.length - 1;
        boolean isFlag = true;
        while (head <= end) {
            int middle = (head + end) / 2;
            if (dest == arr[middle]) {
                System.out.println("找到了，索引位置为：" + middle);
                isFlag = false;
                break;
            } else if (arr[middle] > dest) {
                end = middle - 1;
            } else {
                head = middle + 1;
            }
        }
        if(isFlag){
            System.out.println("很遗憾，没有找到！");
        }
    }
}
~~~



## 回型算法

输入一个数字n，生成回型数字n，数字是n列，n行。并打印。

例如输入3

| 1    | 2    | 3    |
| ---- | ---- | ---- |
| 8    | 9    | 4    |
| 7    | 6    | 5    |

例如输入5

| 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- |
| 16   | 17   | 18   | 19   | 6    |
| 15   | 24   | 25   | 20   | 7    |
| 14   | 23   | 22   | 21   | 8    |
| 13   | 12   | 11   | 10   | 9    |

分析：

- 最大值为输入值的平方。
- 存在4条线

![image-20201207195704120](https://raw.githubusercontent.com/SaulJWu/images/main/20201207202747.png)

- 走完4个方向为一圈

假设输入5

第一圈

| 方向 | 步数 | 这条线多少个数字 | 见到倒数第n个截止 | 生成值      |
| ---- | ---- | ---------------- | ----------------- | ----------- |
| 向右 | 4    | 5                | 1                 | 1 2 3 4     |
| 向下 | 4    | 5                | 1                 | 5 6 7 8     |
| 向左 | 4    | 5                | 1                 | 9 10 11 12  |
| 向上 | 4    | 5                | 1                 | 13 14 15 16 |

第二圈

| 方向 | 步数 | 这条线多少个数字 | 见到倒数第n个截止 | 生成值 |
| ---- | ---- | ---------------- | ----------------- | ------ |
| 向右 | 2    | 5                | 2                 | 17 18  |
| 向下 | 2    | 5                | 2                 | 19 20  |
| 向左 | 2    | 5                | 2                 | 21 22  |
| 向上 | 2    | 5                | 2                 | 23 24  |

~~~java
package arrayTest;

import java.util.Scanner;

/**
 * 输入一个数字n，生成回型数字n，数字是n列，n行。并打印。
 */
public class Demo7 {
    public static void main(String[] args) {
        //获取输入的数字
        //初始化化二维数组
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个数字，将会自动成回形数：");
        if (!scan.hasNextInt()) {
            System.out.println("您输入的不是数字！");
        }
        int input = scan.nextInt();
        if (input <= 0) {
            System.out.println("请输入正整数！");
            return;
        }
        int[][] arr = new int[input][input];
        //控制赋值数字
        int count = 0;
        for (int i = 0; i < input * input; i++) {
            //向右，y轴不变，x轴自增，最多写入倒数第二个
            for (int y = i, x = i; x < input - i - 1; x++) {
                count++;
                arr[y][x] = count;
            }
            //向下，x轴不变，y轴自增，最多写入倒数第二个
            for (int y = i, x = input - i - 1; y < input - i - 1; y++) {
                count++;
                arr[y][x] = count;
            }
            //向左，y轴不变，x轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = input - i - 1; x > i; x--) {
                count++;
                arr[y][x] = count;

            }
            //向上，x轴不变，y轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = i; y > i; y--) {
                count++;
                arr[y][x] = count;
            }
        }
        //输出
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.println();
        }

    }
}
~~~

输入5：

```
1	2	3	4	5	
16	17	18	19	6	
15	24	0	20	7	
14	23	22	21	8	
13	12	11	10	9	
```

输入6：

```
1	2	3	4	5	6	
20	21	22	23	24	7	
19	32	33	34	25	8	
18	31	36	35	26	9	
17	30	29	28	27	10	
16	15	14	13	12	11
```

输入3：

```
1	2	3	
8	0	4	
7	6	5
```

发现了一个bug，当数字为奇数的时候，为0，那么很简单，只需要计算出来单独设置就可以了。

~~~java
//当为奇数时，需要单独设置中心点数字
if (input % 2 != 0) {
    arr[input / 2][input / 2] = input * input;
}
~~~

完整代码如下：

~~~java
package arrayTest;

import java.util.Scanner;

/**
 * 输入一个数字n，生成回型数字n，数字是n列，n行。并打印。
 */
public class Demo7 {
    public static void main(String[] args) {
        //获取输入的数字
        //初始化化二维数组
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个数字，将会自动成回形数：");
        if (!scan.hasNextInt()) {
            System.out.println("您输入的不是数字！");
        }
        int input = scan.nextInt();
        if (input <= 0) {
            System.out.println("请输入正整数！");
            return;
        }
        int[][] arr = new int[input][input];
        //当为奇数时，需要单独设置中心点数字
        if (input % 2 != 0) {
            arr[input / 2][input / 2] = input * input;
        }
        //控制赋值数字
        int count = 0;
        for (int i = 0; i < input * input; i++) {
            //向右，y轴不变，x轴自增，最多写入倒数第二个
            for (int y = i, x = i; x < input - i - 1; x++) {
                count++;
                arr[y][x] = count;
            }
            //向下，x轴不变，y轴自增，最多写入倒数第二个
            for (int y = i, x = input - i - 1; y < input - i - 1; y++) {
                count++;
                arr[y][x] = count;
            }
            //向左，y轴不变，x轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = input - i - 1; x > i; x--) {
                count++;
                arr[y][x] = count;

            }
            //向上，x轴不变，y轴自减，最多写入倒数第二个
            for (int y = input - i - 1, x = i; y > i; y--) {
                count++;
                arr[y][x] = count;
            }
        }
        //输出
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.println();
        }

    }
}
~~~



似乎还有另一种走法：

![image-20201207195752590](https://raw.githubusercontent.com/SaulJWu/images/main/20201207202747.png)



~~~java
package arrayTest;

import java.util.Scanner;

/**
 * 输入一个数字n，生成回型数字n，数字是n列，n行。并打印。
 */
public class Demo8 {
    public static void main(String[] args) {
        //获取输入的数字
        //初始化化二维数组
        Scanner scan = new Scanner(System.in);
        System.out.println("请输入一个数字，将会自动成回形数：");
        if (!scan.hasNextInt()) {
            System.out.println("您输入的不是数字！");
        }
        int input = scan.nextInt();
        if (input <= 0) {
            System.out.println("请输入正整数！");
            return;
        }
        int[][] arr = new int[input][input];
        //控制赋值数字
        int count = 0;
        for (int i = 0; i < input * input; i++) {
            //向右，y轴不变，x轴自增
            for (int y = i, x = i; x < input - i; x++) {
                count++;
                arr[y][x] = count;
            }
            //向下，x轴不变，y轴自增
            for (int y = i + 1, x = input - i - 1; y < input - i; y++) {
                count++;
                arr[y][x] = count;
            }
            //向左，y轴不变，x轴自减
            for (int y = input - i - 1, x = input - i - 2; x >= i; x--) {
                count++;
                arr[y][x] = count;

            }
            //向上，x轴不变，y轴自减
            for (int y = input - i - 2, x = i; y > i; y--) {
                count++;
                arr[y][x] = count;
            }
        }
        //输出
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                System.out.print(arr[i][j] + "\t");
            }
            System.out.println();
        }
    }
}
~~~



至此，已经实现了回型算法！



## 冒泡排序

