---
title: 运算符
date: 2020-12-04 19:29:14
permalink: /pages/aa0283/
categories:
  - 后端
  - Java
tags:
  - 运算符
---

## 定义
运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。

- 算术运算符
- 赋值运算符
- 比较运算符（关系运算符）
- 逻辑运算符
- 位运算符
- 三元运算符

其中，位运算符，在实际开发中用得很少。但看系统源码的时候，会有位运算符，所以还是需要去了解。



## 算术运算符

### 算术运算符概览

| 运算符 | 运算                 | 范例       | 结果    |
| ------ | -------------------- | ---------- | ------- |
| +      | 正号                 | +3         | 3       |
| -      | 负号                 | b=4;-b     | -4      |
| +      | 加                   | 5+5        | 10      |
| -      | 减                   | 6-4        | 2       |
| *      | 乘                   | 3*4        | 12      |
| /      | 除                   | 5/5        | 1       |
| %      | 取模（取余）         | 7%5        | 2       |
| 前缀++ | 自增前：先运算再取值 | a=2;b=++a  | a=3;b=3 |
| 后缀++ | 自增后：先取值后运算 | a=2;b=a++; | a=3;b=2 |
| 前缀—  | 自减前：先运算后取值 | a=2;b=— a; | a=1;b=1 |
| 后缀—  | 自减后：先取值后运算 | a=2;b=a—   | a=1;b=2 |
| +      | 字符串连接           | "He"+"llo" | "Hello" |



在Java中

### 除号 /

> 整数12/整数5结果是？

~~~java
int num1 = 12;
int num2 = 5;
int result1 = num1 / num2; //2
~~~

整形会截尾整数，所以结果是2

> 接下来在上面案例中，再加上

~~~java
int result2 = num1 / num2 * num2;
~~~

结果是10。

> 猜猜下面的结果：

~~~java
double result3 = num1 / num2
~~~

结果是2.0。

为什么？

因为先算`num1 / num2`，得出的结果是`2`，然后把2赋值给`result3`

> 那么不改变num1和num2的情况下，如何能达到精确结果？

~~~java
double result4 = num1 / (num2 + 0.0); // 2.4
~~~

~~~java
double result5 = (double)num1 / num2; // 2.4
~~~

- 小结

只要把其中一个转换为`double`，就可以求得到精确结果。



### 取模 %

取模其实就是取余数，比如7/5=1余2，所以取出2作为结果。开发中，经常使用%来判断能否被除尽的情况。

比如：取模2，就可以判断奇偶数，10%2=0，偶数，11%2=1，奇数。

在取模运算中，除数叫模数，被除数叫被模数。例如10%2=0，这个公式中，10是被模数，2是模数。跟除数和被除数的概念一样。

> 来看看下面的案例，每个result的结果分别是多少？

~~~java
int m1 = 12;
int n1 = 5;
int result1 = m1 % n1;

int m2 = -12;
int n2 = 5;
int result2 = m2 % n2;

int m3 = 12;
int n3 = -5;
int result3 = m3 % n3;

int m4 = -12;
int n4 = -5;
int result1 = m4 % n4;
~~~

```java
12 % 5 = 2
-12 % 5 = -2
12 % -5 = 2
-12 % -5 = -2
```

- 小结

取模结果的符号与被模数的符号一致。



### 前缀++和后缀++

> a1,b1和a2,b2分别是多少？

~~~java
int a1 = 10;
int b1 = ++a1;

int a2 = 10;
int b2 = a2+=;
~~~

~~~java
a1 = 11,b1 = 11;
a2 = 11,b2 = 10;
~~~

- 小结：

前缀++先自增1，然后再运算。

后缀++先运算，然后再自增1。



> a3和b3分别是多少？

~~~java
int a3 = 10;
a3++;
int b3 = a3;
~~~

a3=11,b3=11

> a4和b4分别是多少？

~~~java
int a4 = 10;
++a4;
int b4 = a4;
~~~

a4=11,b4=11

如果单独一行写自增运算，其实没有区别，也不会影响后面的赋值运算。



- 注意点

~~~java
short s1 = 10;
s1 = s1 + 1;//编译失败
s1 = (short)(s1 + 1);//正确的
s1++;//编译通过
~~~

小结：自增1不会改变本身变量的数据类型。



- 问题

下面能编译通过吗？会转换为int？结果是多少？

~~~java
byte b1 = 127;
b1++;
~~~

编译会通过，因为自增1不会改变本身变量的数据类型。

结果是-128，因为已经超出byte的范围了。

用二进制的方式解释：下面是127的二进制图

| 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

当自增1后

| 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

由于第一位是符号位，所以变成-128。

### 前缀—和后缀—

前缀—：先自减1，后运算

后缀—：先运算，后子减1

跟前缀++和后缀++类似，可以触类旁通。

~~~java
int a1 = 10;
int b1 = --a1;
~~~

结果a1=9,b1=9。

~~~java
int a2 = 10;
int b2 = a2--;
~~~

结果a2=9，b2=10。



### 练习1

~~~java
int i1 = 10;
int i2 = 20;
int i = i1++;
System.out.print("i="+i);//?
System.out.print("i1="+i1);//?
i = ++i1;
System.out.print("i="+i);//?
System.out.print("i1="+i1);//?
i = i2--;
System.out.print("i="+i);//?
System.out.print("i2="+i2);//？
i = --i2;
System.out.print("i="+i);//?
System.out.print("i2="+i2);//?
~~~

~~~java
i=10;i1=11;
i=12;i1=12;
i=20;i2=19;
i=18;i2=18;
~~~



### 练习2

随意给出一个整数，打印显示它的个位数，十位数，百位数的值。

格式如下：

数字XXX的情况如下：

个位数：

十位数：

百位数：



例如：

数字153的情况如下：

个位数：3

十位数：5

百位数：1



~~~java
class AreExer{
    public statis void main(String[] args){
        int num = 187;
        int bai = num / 100;
        int shi = num % 100 / 10; // int shi = num / 10 % 10
        int ge = num % 10;
        System.out.println("数字"+num+"的情况如下：");
        System.out.println("个位数："+ge);
        System.out.println("十位数："+shi);
        System.out.println("百位数："+bai);
    }
}
~~~





## 赋值运算符

- 符号：=
  - 当“=”两侧数据类型不一致时，可以使用自动类型转换或使用枪支类型转换原则进行处理。
  - 支持持续赋值。
- 拓展赋值运算符：`+=`,`-=`,`*=`,`/=`,`%=`