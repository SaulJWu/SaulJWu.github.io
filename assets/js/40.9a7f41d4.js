(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{646:function(v,_,t){"use strict";t.r(_);var l=t(20),d=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"类的成员"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的成员"}},[v._v("#")]),v._v(" 类的成员")]),v._v(" "),t("p",[v._v("Java的基本单位是类"),t("code",[v._v("class")]),v._v("，Java成员即类中的成员，包括以下五个部分：")]),v._v(" "),t("ul",[t("li",[v._v("属性")]),v._v(" "),t("li",[v._v("方法")]),v._v(" "),t("li",[v._v("构造器")]),v._v(" "),t("li",[v._v("代码块/初始化块")]),v._v(" "),t("li",[v._v("内部类")])]),v._v(" "),t("h2",{attrs:{id:"类的属性field"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类的属性field"}},[v._v("#")]),v._v(" 类的属性"),t("code",[v._v("field")])]),v._v(" "),t("p",[v._v("其中属性也可以叫"),t("strong",[v._v("成员变量")]),v._v("或者"),t("strong",[v._v("字段")]),v._v("，方法也可以叫函数。")]),v._v(" "),t("p",[v._v("在类内部声明的变量，称为==成员变量==。")]),v._v(" "),t("p",[v._v("在方法体内部声明的变量，称为==局部变量==。")]),v._v(" "),t("blockquote",[t("p",[v._v("属性的语法格式")])]),v._v(" "),t("p",[v._v("修饰符 数据类型 属性名 =  初始化值;")]),v._v(" "),t("ul",[t("li",[v._v("修饰符\n"),t("ul",[t("li",[v._v("常用的权限修饰符有：private、缺省、protected、public")]),v._v(" "),t("li",[v._v("其他修饰符：static、final (暂不考虑)")])])]),v._v(" "),t("li",[v._v("数据类型\n"),t("ul",[t("li",[v._v("任何基本数据类型(如int、Boolean) 或任何引用数据类型。")])])]),v._v(" "),t("li",[v._v("属性名\n"),t("ul",[t("li",[v._v("属于标识符，符合命名规则和规范即可。")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("属性（成员变量）与局部变量的区别")])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th"),v._v(" "),t("th",[v._v("成员变量")]),v._v(" "),t("th",[v._v("局部变量")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("声明的位置")]),v._v(" "),t("td",[v._v("直接在类中声明")]),v._v(" "),t("td",[v._v("方法形参或内部、代码块内、构造器内等")])]),v._v(" "),t("tr",[t("td",[v._v("修饰符")]),v._v(" "),t("td",[v._v("private、public、static、final等")]),v._v(" "),t("td",[v._v("不能用权限修饰符修饰，可以用final修饰")])]),v._v(" "),t("tr",[t("td",[v._v("初始化值")]),v._v(" "),t("td",[v._v("有默认初始化值")]),v._v(" "),t("td",[v._v("没有默认初始化值，必须显式赋值，方可使用")])]),v._v(" "),t("tr",[t("td",[v._v("内存加载位置")]),v._v(" "),t("td",[v._v("堆空间或静态域内")]),v._v(" "),t("td",[v._v("栈空间")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("属性（成员变量）与局部变量的相同点")])]),v._v(" "),t("ul",[t("li",[v._v("定义变量的格式：数据类型 变量明 = 变量值")]),v._v(" "),t("li",[v._v("先声明，后使用")]),v._v(" "),t("li",[v._v("变量都有其对应的作用域")])]),v._v(" "),t("blockquote",[t("p",[v._v("成员变量的基本类型默认值")])]),v._v(" "),t("p",[v._v("如果类的成员变量（字段）是基本数据类型，那么在类初始化（实例化）时，这些类型将会被赋予一个初始值。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("基本类型")]),v._v(" "),t("th",[v._v("初始值")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("boolean")]),v._v(" "),t("td",[v._v("false")])]),v._v(" "),t("tr",[t("td",[v._v("char")]),v._v(" "),t("td",[v._v("\\u0000 (null)")])]),v._v(" "),t("tr",[t("td",[v._v("byte")]),v._v(" "),t("td",[v._v("(byte) 0")])]),v._v(" "),t("tr",[t("td",[v._v("short")]),v._v(" "),t("td",[v._v("(short) 0")])]),v._v(" "),t("tr",[t("td",[v._v("int")]),v._v(" "),t("td",[v._v("0")])]),v._v(" "),t("tr",[t("td",[v._v("long")]),v._v(" "),t("td",[v._v("0L")])]),v._v(" "),t("tr",[t("td",[v._v("float")]),v._v(" "),t("td",[v._v("0.0f")])]),v._v(" "),t("tr",[t("td",[v._v("double")]),v._v(" "),t("td",[v._v("0.0d")])])])]),v._v(" "),t("p",[v._v("这些默认值仅在 Java 初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在 C++ 中不会），从而减少了 bug 的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。 所以，为了安全，我们最好始终显式地初始化变量。")]),v._v(" "),t("p",[v._v("这种默认值的赋予并不适用于局部变量 —— 那些不属于类的字段的变量。")])])}),[],!1,null,null,null);_.default=d.exports}}]);