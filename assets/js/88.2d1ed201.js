(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{578:function(e,t,v){"use strict";v.r(t);var _=v(15),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),v("p",[v("code",[e._v("Java")]),e._v(" 集合可分为"),v("code",[e._v("Collection")]),e._v(" 和"),v("code",[e._v("Map")]),e._v(" 两种体系:")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("Collection")]),e._v("接口：单列数据，定义了存取一组对象的方法的集合\n"),v("ul",[v("li",[v("code",[e._v("List")]),e._v("：元素有序、可重复的集合\n"),v("ul",[v("li",[v("code",[e._v("ArrayList")]),e._v("、"),v("code",[e._v("LinkedList")]),e._v("、"),v("code",[e._v("Vector")])])])]),e._v(" "),v("li",[v("code",[e._v("Set")]),e._v("：元素无序、不可重复的集合\n"),v("ul",[v("li",[v("code",[e._v("HashSet")]),e._v("、"),v("code",[e._v("LinkedHashSet")]),e._v("、"),v("code",[e._v("TreeSet")])])])])])]),e._v(" "),v("li",[v("code",[e._v("Map")]),e._v("接口：双列数据，保存具有映射关系“"),v("code",[e._v("key-value对")]),e._v("”的集合，也称为"),v("strong",[e._v("键值对")]),e._v("。\n"),v("ul",[v("li",[v("code",[e._v("HashMap")]),e._v("、"),v("code",[e._v("LinkedHashMap")]),e._v("、"),v("code",[e._v("TreeMap")]),e._v("、"),v("code",[e._v("Hashtable")]),e._v("、"),v("code",[e._v("Properties")])])])])]),e._v(" "),v("p",[v("strong",[e._v("接下来学习Set接口的实现类"),v("code",[e._v("LinkedHashSet")])])]),e._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),v("ul",[v("li",[e._v("LinkedHashSet是HashSet的子类")]),e._v(" "),v("li",[v("strong",[e._v("LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。")])]),e._v(" "),v("li",[e._v("LinkedHashSet插入性能略低于HashSet，但在迭代访问Set 里的全部元素时有很好的性能。")]),e._v(" "),v("li",[e._v("LinkedHashSet不允许集合元素重复。")])]),e._v(" "),v("h2",{attrs:{id:"底层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#底层"}},[e._v("#")]),e._v(" 底层")]),e._v(" "),v("p",[e._v("这么看来LinkedHashSet和HashSet的底层都差不多，只是用了双向链表来指向元素的位置。")]),e._v(" "),v("h2",{attrs:{id:"顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#顺序"}},[e._v("#")]),e._v(" 顺序")]),e._v(" "),v("blockquote",[v("p",[e._v("什么时候维护元素的次序？")])]),e._v(" "),v("p",[e._v("在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个元素和后一个元素。所以LinkedHashSet插入性能略低于HashSet。")]),e._v(" "),v("p",[e._v("比如：")]),e._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/SaulJWu/images/main/20201226202605.png",alt:"image-20201226202605110"}})]),e._v(" "),v("p",[e._v("AA是第一个添加的，所以前一个元素为null，后面一个元素是456……")]),e._v(" "),v("p",[e._v("既然LinkedHashSet知道了元素的位置，那么遍历的时候，也就是迭代访问Set 里的全部元素时有很好的性能。")])])}),[],!1,null,null,null);t.default=a.exports}}]);