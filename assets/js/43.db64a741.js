(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{533:function(v,_,t){"use strict";t.r(_);var e=t(15),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),t("p",[t("strong",[v._v("面向对象的三大特征：")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("封装 ("),t("code",[v._v("Encapsulation")]),v._v(")")])]),v._v(" "),t("li",[t("p",[v._v("继承 ("),t("code",[v._v("Inheritance")]),v._v(")")])]),v._v(" "),t("li",[t("p",[v._v("多态 ("),t("code",[v._v("Polymorphism")]),v._v(")")])])]),v._v(" "),t("p",[v._v("接下来我们通过3W类学习封装。")]),v._v(" "),t("ul",[t("li",[v._v("what？")]),v._v(" "),t("li",[v._v("why？")]),v._v(" "),t("li",[v._v("how？\n封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节私有化把接口与实现分离。")])]),v._v(" "),t("h2",{attrs:{id:"含义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#含义"}},[v._v("#")]),v._v(" 含义")]),v._v(" "),t("blockquote",[t("p",[v._v("==为什么需要封装？封装的作用和含义？==")])]),v._v(" "),t("ul",[t("li",[v._v("我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？")]),v._v(" "),t("li",[v._v("我要开车，...")])]),v._v(" "),t("p",[v._v("（当然，作为程序员还是要了解内部的结构以及运转机制的（底层原理），这样子才会清楚掌握程序，而且面试时也加分）")]),v._v(" "),t("blockquote",[t("p",[v._v("==程序设计追求“高内聚，低耦合”。==")])]),v._v(" "),t("ul",[t("li",[v._v("高内聚：类的内部数据操作细节自己完成，不允许外部干涉；")]),v._v(" "),t("li",[v._v("低耦合：仅对外暴露少量的方法用于使用。")])]),v._v(" "),t("p",[v._v("隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，==把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。==")]),v._v(" "),t("h2",{attrs:{id:"问题引入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#问题引入"}},[v._v("#")]),v._v(" 问题引入")]),v._v(" "),t("p",[v._v("使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题。")]),v._v(" "),t("p",[v._v("当我们创建一个类的对象以后，如果不去控制权限，就可以通过"),t("code",[v._v("对象.属性")]),v._v("的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际业务场景中，往往需要给属性赋值加入额外的限制条件，这个条件必须通过方法来实现。")]),v._v(" "),t("p",[v._v("那么需要做的是把"),t("code",[v._v("对象.属性")]),v._v("这个权限私有化，把设置属性的方法暴露。")]),v._v(" "),t("h2",{attrs:{id:"封装性的体现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装性的体现"}},[v._v("#")]),v._v(" 封装性的体现")]),v._v(" "),t("p",[v._v("Java中通过将数据声明为私有的("),t("code",[v._v("private")]),v._v(")，再提供公共的（"),t("code",[v._v("public")]),v._v("）方法:"),t("code",[v._v("getXxx()")]),v._v("和"),t("code",[v._v("setXxx()")]),v._v("实现对该属性的操作，以实现下述目的：")]),v._v(" "),t("ul",[t("li",[v._v("隐藏一个类中不需要对外提供的实现细节")]),v._v(" "),t("li",[v._v("使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；")]),v._v(" "),t("li",[v._v("便于修改，增强代码的可维护性")])]),v._v(" "),t("blockquote",[t("p",[v._v("拓展，其他体现封装性的现象")])]),v._v(" "),t("ul",[t("li",[v._v("不对外暴漏的私有("),t("code",[v._v("private")]),v._v(")方法")]),v._v(" "),t("li",[v._v("单例模式")]),v._v(" "),t("li",[v._v("……")])]),v._v(" "),t("p",[v._v("以上只是封装性的体现之一，不等同于封装性。")]),v._v(" "),t("h2",{attrs:{id:"权限修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#权限修饰符"}},[v._v("#")]),v._v(" 权限修饰符")]),v._v(" "),t("blockquote",[t("p",[v._v("封装性的体现，需要权限来配合。")])]),v._v(" "),t("p",[v._v("Java权限修饰符"),t("code",[v._v("public")]),v._v("、"),t("code",[v._v("protected")]),v._v("、default(缺省)、"),t("code",[v._v("private")]),v._v("置于类的成员定义前，用来限定对象对该类成员的访问权限。")]),v._v(" "),t("p",[v._v("权限从小到大排列： "),t("code",[v._v("private")]),v._v("、default(缺省)、"),t("code",[v._v("protected")]),v._v("、"),t("code",[v._v("public")]),v._v("。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("修饰符")]),v._v(" "),t("th",[v._v("类内部")]),v._v(" "),t("th",[v._v("同一个包")]),v._v(" "),t("th",[v._v("不同包")]),v._v(" "),t("th",[v._v("同一个工程")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("private")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("default(缺省)")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td"),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("protected")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("public")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td",[v._v("yes")]),v._v(" "),t("td",[v._v("yes")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("4种权限可以用来修饰类及类的内部结构")])]),v._v(" "),t("ul",[t("li",[v._v("类的内部结构：属性、方法、构造器、内部类")]),v._v(" "),t("li",[v._v("类：对于class的权限修饰只可以用"),t("code",[v._v("public")]),v._v("和"),t("code",[v._v("default")]),v._v("(缺省)。\n"),t("ul",[t("li",[t("code",[v._v("public")]),v._v("类可以在任意地方被访问。")]),v._v(" "),t("li",[t("code",[v._v("default")]),v._v("类只可以被同一个包内部的类访问。")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/SaulJWu/images/main/20201211101241.png",alt:"image-20201211101234459"}})]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("我们可以把编程的侧重领域划分为研发和应用。应用程序员调用研发程序员构建的基础工具类来做快速开发。研发程序员开发一个工具类，该工具类仅向应用程序员公开必要的内容，并隐藏内部实现的细节。这样可以有效地避免该工具类被错误的使用和更改，从而减少程序出错的可能。彼此职责划分清晰，相互协作。当应用程序员调用研发程序员开发的工具类时，双方建立了关系。应用程序员通过使用现成的工具类组装应用程序或者构建更大的工具库。如果工具类的创建者将类的内部所有信息都公开给调用者，那么有些使用规则就不容易被遵守。因为前者无法保证后者是否会按照正确的规则来使用，甚至是改变该工具类。只有设定访问控制，才能从根本上阻止这种情况的发生。")])])}),[],!1,null,null,null);_.default=a.exports}}]);