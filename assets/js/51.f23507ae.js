(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{666:function(t,e,a){"use strict";a.r(e);var s=a(20),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"子类对象实例化的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子类对象实例化的过程"}},[t._v("#")]),t._v(" 子类对象实例化的过程")]),t._v(" "),a("blockquote",[a("p",[t._v("当我们实例化子类时，会产生一系列过程")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/SaulJWu/images/main/20201211175408.png",alt:"image-20201211175408564"}})]),t._v(" "),a("blockquote",[a("p",[t._v("思考")]),t._v(" "),a("p",[t._v("1、为什么super(...)和this(...)调用语句不能同时在一个构造器中出现？")]),t._v(" "),a("p",[t._v("2、为什么super(...)或this(...)调用语句只能作为构造器中的第一句出现？")])]),t._v(" "),a("p",[t._v("比如下图中的new Dog()")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/SaulJWu/images/main/20201211174604.png",alt:"image-20201211174603981"}})]),t._v(" "),a("blockquote",[a("p",[t._v("从结果上来看")])]),t._v(" "),a("p",[t._v("子类继承父类以后，就获取了父类中声明的属性或方法。")]),t._v(" "),a("p",[t._v("创建子类的对象，在堆空间中，就会加载所有所有父类声明的属性。")]),t._v(" "),a("blockquote",[a("p",[t._v("从过程上来看")])]),t._v(" "),a("p",[t._v("当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了"),a("code",[t._v("java.lang.Object")]),t._v("类中空参的构造器为止。正因为加载过所有的弗雷的结构，搜所以才可以看到内存中有父类的结构，子类对象才可以考虑进行调用。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://raw.githubusercontent.com/SaulJWu/images/main/20201211175309.png",alt:"image-20201211175309640"}}),t._v(" "),a("p",[a("strong",[t._v("明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建一个对象，即为"),a("code",[t._v("new")]),t._v("的子类对象。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);