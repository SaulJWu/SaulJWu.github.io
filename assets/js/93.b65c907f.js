(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{584:function(e,v,_){"use strict";_.r(v);var o=_(15),c=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),_("p",[_("code",[e._v("Java")]),e._v(" 集合可分为"),_("code",[e._v("Collection")]),e._v(" 和"),_("code",[e._v("Map")]),e._v(" 两种体系:")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("Collection")]),e._v("接口：单列数据，定义了存取一组对象的方法的集合\n"),_("ul",[_("li",[_("code",[e._v("List")]),e._v("：元素有序、可重复的集合\n"),_("ul",[_("li",[_("code",[e._v("ArrayList")]),e._v("、"),_("code",[e._v("LinkedList")]),e._v("、"),_("code",[e._v("Vector")])])])]),e._v(" "),_("li",[_("code",[e._v("Set")]),e._v("：元素无序、不可重复的集合\n"),_("ul",[_("li",[_("code",[e._v("HashSet")]),e._v("、"),_("code",[e._v("LinkedHashSet")]),e._v("、"),_("code",[e._v("TreeSet")])])])])])]),e._v(" "),_("li",[_("code",[e._v("Map")]),e._v("接口：双列数据，保存具有映射关系“"),_("code",[e._v("key-value对")]),e._v("”的集合，也称为"),_("strong",[e._v("键值对")]),e._v("。\n"),_("ul",[_("li",[_("code",[e._v("HashMap")]),e._v("、"),_("code",[e._v("LinkedHashMap")]),e._v("、"),_("code",[e._v("TreeMap")]),e._v("、"),_("code",[e._v("Hashtable")]),e._v("、"),_("code",[e._v("Properties")])])])])]),e._v(" "),_("p",[_("strong",[e._v("现在我们开始学习"),_("code",[e._v("TreeMap")]),e._v("。")])]),e._v(" "),_("h2",{attrs:{id:"概述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[e._v("#")]),e._v(" 概述")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("TreeMap")]),e._v("存储"),_("code",[e._v("Key-Value 对")]),e._v("时，需要根据"),_("code",[e._v("key-value")]),e._v(" 对进行排序。"),_("code",[e._v("TreeMap")]),e._v("可以保证所有的"),_("code",[e._v("Key-Value")]),e._v(" 对处于"),_("strong",[e._v("有序")]),e._v("状态。")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("TreeMap")]),e._v("底层使用"),_("strong",[e._v("红黑树结构存")]),e._v("储数据")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("TreeMap")]),e._v("的"),_("code",[e._v("Key")]),e._v(" 的排序：")]),e._v(" "),_("ul",[_("li",[e._v("自然排序："),_("code",[e._v("TreeMap")]),e._v("的所有的"),_("code",[e._v("Key")]),e._v(" 必须实现"),_("code",[e._v("Comparable")]),e._v(" 接口，而且所有的"),_("code",[e._v("Key")]),e._v(" 应该是同一个类的对象，否则将会抛出"),_("code",[e._v("ClasssCastException")])]),e._v(" "),_("li",[e._v("定制排序：创建"),_("code",[e._v("TreeMap")]),e._v("时，传入一个"),_("code",[e._v("Comparator")]),e._v("对象，该对象负责对"),_("code",[e._v("TreeMap")]),e._v("中的所有"),_("code",[e._v("key")]),e._v("进行排序。此时不需要"),_("code",[e._v("Map")]),e._v("的"),_("code",[e._v("Key")]),e._v(" 实现"),_("code",[e._v("Comparable")]),e._v("接口")])])]),e._v(" "),_("li",[_("p",[_("code",[e._v("TreeMap")]),e._v("判断两个"),_("code",[e._v("key")]),e._v("相等的标准：两个"),_("code",[e._v("key")]),e._v("通过"),_("code",[e._v("compareTo()")]),e._v("方法或者"),_("code",[e._v("compare()")]),e._v("方法返回"),_("code",[e._v("0")]),e._v("。")])])]),e._v(" "),_("p",[e._v("这里就不做展开了，因为之前TreeSet中也测试过了，有疑问可以提出。")])])}),[],!1,null,null,null);v.default=c.exports}}]);