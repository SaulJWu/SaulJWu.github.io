(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{629:function(_,v,t){"use strict";t.r(v);var i=t(15),l=Object(i.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"什么是设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是设计模式"}},[_._v("#")]),_._v(" 什么是设计模式？")]),_._v(" "),t("p",[_._v("设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。")]),_._v(" "),t("p",[_._v("设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本"),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Design_Patterns",target:"_blank",rel:"noopener noreferrer"}},[_._v("Design Patterns"),t("OutboundLink")],1),_._v("的书。这四人也被称为四人帮（GoF）。")]),_._v(" "),t("p",[_._v("为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：")]),_._v(" "),t("h3",{attrs:{id:"开闭原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[_._v("#")]),_._v(" 开闭原则")]),_._v(" "),t("p",[_._v("由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。")]),_._v(" "),t("h3",{attrs:{id:"里氏替换原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[_._v("#")]),_._v(" 里氏替换原则")]),_._v(" "),t("p",[_._v("里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。")]),_._v(" "),t("p",[_._v("设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。")]),_._v(" "),t("p",[_._v("学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。")]),_._v(" "),t("h2",{attrs:{id:"模式分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模式分类"}},[_._v("#")]),_._v(" 模式分类")]),_._v(" "),t("ul",[t("li",[_._v("创建型模式\n"),t("ul",[t("li",[_._v("创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。")]),_._v(" "),t("li",[_._v("创建型模式包括：\n"),t("ul",[t("li",[_._v("工厂方法：Factory Method")]),_._v(" "),t("li",[_._v("抽象工厂：Abstract Factory")]),_._v(" "),t("li",[_._v("建造者：Builder")]),_._v(" "),t("li",[_._v("原型：Prototype")]),_._v(" "),t("li",[_._v("单例：Singleton")])])])])]),_._v(" "),t("li",[_._v("结构型模式\n"),t("ul",[t("li",[_._v("结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。")]),_._v(" "),t("li",[_._v("结构型模式有：\n"),t("ul",[t("li",[_._v("适配器")]),_._v(" "),t("li",[_._v("桥接")]),_._v(" "),t("li",[_._v("组合")]),_._v(" "),t("li",[_._v("装饰器")]),_._v(" "),t("li",[_._v("外观")]),_._v(" "),t("li",[_._v("享元")]),_._v(" "),t("li",[_._v("代理")])])])])]),_._v(" "),t("li",[_._v("行为型模式\n"),t("ul",[t("li",[_._v("行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。")]),_._v(" "),t("li",[_._v("行为型模式有：\n"),t("ul",[t("li",[_._v("责任链")]),_._v(" "),t("li",[_._v("命令")]),_._v(" "),t("li",[_._v("解释器")]),_._v(" "),t("li",[_._v("迭代器")]),_._v(" "),t("li",[_._v("中介")]),_._v(" "),t("li",[_._v("备忘录")]),_._v(" "),t("li",[_._v("观察者")]),_._v(" "),t("li",[_._v("状态")]),_._v(" "),t("li",[_._v("策略")]),_._v(" "),t("li",[_._v("模板方法")]),_._v(" "),t("li",[_._v("访问者")])])])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);